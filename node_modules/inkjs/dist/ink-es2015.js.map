{"version":3,"file":"ink-es2015.js","sources":["../src/engine/Path.ts","../src/engine/Debug.ts","../src/engine/Value.ts","../src/engine/PushPop.ts","../src/engine/Error.ts","../src/engine/TypeAssertion.ts","../src/engine/NullException.ts","../src/engine/Object.ts","../src/engine/StringBuilder.ts","../src/engine/InkList.ts","../src/engine/StoryException.ts","../src/engine/TryGetResult.ts","../src/engine/SearchResult.ts","../src/engine/Container.ts","../src/engine/Glue.ts","../src/engine/ControlCommand.ts","../src/engine/Pointer.ts","../src/engine/Divert.ts","../src/engine/ChoicePoint.ts","../src/engine/VariableReference.ts","../src/engine/VariableAssignment.ts","../src/engine/Void.ts","../src/engine/NativeFunctionCall.ts","../src/engine/Tag.ts","../src/engine/Choice.ts","../src/engine/ListDefinition.ts","../src/engine/ListDefinitionsOrigin.ts","../src/engine/JsonSerialisation.ts","../src/engine/CallStack.ts","../src/engine/VariablesState.ts","../src/engine/PRNG.ts","../src/engine/StatePatch.ts","../src/engine/SimpleJson.ts","../src/engine/Flow.ts","../src/engine/StoryState.ts","../src/engine/StopWatch.ts","../src/engine/Story.ts"],"sourcesContent":["export class Path {\n  public static parentId = \"^\";\n\n  public _isRelative: boolean;\n  public _components: Path.Component[];\n  public _componentsString: string | null;\n\n  constructor();\n  constructor(componentsString: string);\n  constructor(head: Path.Component, tail: Path);\n  constructor(head: Path.Component[], relative?: boolean);\n  constructor() {\n    this._components = [];\n    this._componentsString = null;\n    this._isRelative = false;\n\n    if (typeof arguments[0] == \"string\") {\n      let componentsString = arguments[0] as string;\n      this.componentsString = componentsString;\n    } else if (\n      arguments[0] instanceof Path.Component &&\n      arguments[1] instanceof Path\n    ) {\n      let head = arguments[0] as Path.Component;\n      let tail = arguments[1] as Path;\n      this._components.push(head);\n      this._components = this._components.concat(tail._components);\n    } else if (arguments[0] instanceof Array) {\n      let head = arguments[0] as Path.Component[];\n      let relative = !!arguments[1] as boolean;\n      this._components = this._components.concat(head);\n      this._isRelative = relative;\n    }\n  }\n  get isRelative() {\n    return this._isRelative;\n  }\n  get componentCount(): number {\n    return this._components.length;\n  }\n  get head(): Path.Component | null {\n    if (this._components.length > 0) {\n      return this._components[0];\n    } else {\n      return null;\n    }\n  }\n  get tail(): Path {\n    if (this._components.length >= 2) {\n      // careful, the original code uses length-1 here. This is because the second argument of\n      // List.GetRange is a number of elements to extract, wherease Array.slice uses an index\n      let tailComps = this._components.slice(1, this._components.length);\n      return new Path(tailComps);\n    } else {\n      return Path.self;\n    }\n  }\n  get length(): number {\n    return this._components.length;\n  }\n  get lastComponent(): Path.Component | null {\n    let lastComponentIdx = this._components.length - 1;\n    if (lastComponentIdx >= 0) {\n      return this._components[lastComponentIdx];\n    } else {\n      return null;\n    }\n  }\n  get containsNamedComponent(): boolean {\n    for (let i = 0, l = this._components.length; i < l; i++) {\n      if (!this._components[i].isIndex) {\n        return true;\n      }\n    }\n    return false;\n  }\n  static get self(): Path {\n    let path = new Path();\n    path._isRelative = true;\n    return path;\n  }\n\n  public GetComponent(index: number): Path.Component {\n    return this._components[index];\n  }\n  public PathByAppendingPath(pathToAppend: Path): Path {\n    let p = new Path();\n\n    let upwardMoves = 0;\n    for (let i = 0; i < pathToAppend._components.length; ++i) {\n      if (pathToAppend._components[i].isParent) {\n        upwardMoves++;\n      } else {\n        break;\n      }\n    }\n\n    for (let i = 0; i < this._components.length - upwardMoves; ++i) {\n      p._components.push(this._components[i]);\n    }\n\n    for (let i = upwardMoves; i < pathToAppend._components.length; ++i) {\n      p._components.push(pathToAppend._components[i]);\n    }\n\n    return p;\n  }\n  get componentsString(): string {\n    if (this._componentsString == null) {\n      this._componentsString = this._components.join(\".\");\n      if (this.isRelative)\n        this._componentsString = \".\" + this._componentsString;\n    }\n\n    return this._componentsString;\n  }\n  set componentsString(value: string) {\n    this._components.length = 0;\n\n    this._componentsString = value;\n\n    if (this._componentsString == null || this._componentsString == \"\") return;\n\n    if (this._componentsString[0] == \".\") {\n      this._isRelative = true;\n      this._componentsString = this._componentsString.substring(1);\n    }\n\n    let componentStrings = this._componentsString.split(\".\");\n    for (let str of componentStrings) {\n      // we need to distinguish between named components that start with a number, eg \"42somewhere\", and indexed components\n      // the normal parseInt won't do for the detection because it's too relaxed.\n      // see https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/parseInt\n      if (/^(\\-|\\+)?([0-9]+|Infinity)$/.test(str)) {\n        this._components.push(new Path.Component(parseInt(str)));\n      } else {\n        this._components.push(new Path.Component(str));\n      }\n    }\n  }\n  public toString(): string {\n    return this.componentsString;\n  }\n  public Equals(otherPath: Path | null): boolean {\n    if (otherPath == null) return false;\n\n    if (otherPath._components.length != this._components.length) return false;\n\n    if (otherPath.isRelative != this.isRelative) return false;\n\n    // the original code uses SequenceEqual here, so we need to iterate over the components manually.\n    for (let i = 0, l = otherPath._components.length; i < l; i++) {\n      // it's not quite clear whether this test should use Equals or a simple == operator,\n      // see https://github.com/y-lohse/inkjs/issues/22\n      if (!otherPath._components[i].Equals(this._components[i])) return false;\n    }\n\n    return true;\n  }\n  public PathByAppendingComponent(c: Path.Component): Path {\n    let p = new Path();\n    p._components.push(...this._components);\n    p._components.push(c);\n    return p;\n  }\n}\n\nexport namespace Path {\n  export class Component {\n    public readonly index: number;\n    public readonly name: string | null;\n\n    constructor(indexOrName: string | number) {\n      this.index = -1;\n      this.name = null;\n      if (typeof indexOrName == \"string\") {\n        this.name = indexOrName;\n      } else {\n        this.index = indexOrName;\n      }\n    }\n    get isIndex(): boolean {\n      return this.index >= 0;\n    }\n    get isParent(): boolean {\n      return this.name == Path.parentId;\n    }\n\n    public static ToParent(): Component {\n      return new Component(Path.parentId);\n    }\n    public toString(): string | null {\n      if (this.isIndex) {\n        return this.index.toString();\n      } else {\n        return this.name;\n      }\n    }\n    public Equals(otherComp: Component): boolean {\n      if (otherComp != null && otherComp.isIndex == this.isIndex) {\n        if (this.isIndex) {\n          return this.index == otherComp.index;\n        } else {\n          return this.name == otherComp.name;\n        }\n      }\n\n      return false;\n    }\n  }\n}\n","export namespace Debug {\n  export function AssertType<T>(\n    variable: any,\n    type: new () => T,\n    message: string\n  ): void | never {\n    Assert(variable instanceof type, message);\n  }\n\n  export function Assert(condition: boolean, message?: string): void | never {\n    if (!condition) {\n      if (typeof message !== \"undefined\") {\n        console.warn(message);\n      }\n\n      if (console.trace) {\n        console.trace();\n      }\n\n      throw new Error(\"\");\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { StoryException } from \"./StoryException\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { tryParseInt, tryParseFloat } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport abstract class AbstractValue extends InkObject {\n  public abstract get valueType(): ValueType;\n  public abstract get isTruthy(): boolean;\n  public abstract get valueObject(): any;\n\n  public abstract Cast(newType: ValueType): Value<any>;\n\n  public static Create(\n    val: any,\n    preferredNumberType?: ValueType\n  ): Value<any> | null {\n    // This code doesn't exist in upstream and is simply here to enforce\n    // the creation of the proper number value.\n    // If `preferredNumberType` is not provided or if value doesn't match\n    // `preferredNumberType`, this conditional does nothing.\n    if (preferredNumberType) {\n      if (\n        preferredNumberType === (ValueType.Int as ValueType) &&\n        Number.isInteger(Number(val))\n      ) {\n        return new IntValue(Number(val));\n      } else if (\n        preferredNumberType === (ValueType.Float as ValueType) &&\n        !isNaN(val)\n      ) {\n        return new FloatValue(Number(val));\n      }\n    }\n\n    if (typeof val === \"boolean\") {\n      return new BoolValue(Boolean(val));\n    }\n\n    // https://github.com/y-lohse/inkjs/issues/425\n    // Changed condition sequence, because Number('') is\n    // parsed to 0, which made setting string to empty\n    // impossible\n    if (typeof val === \"string\") {\n      return new StringValue(String(val));\n    } else if (Number.isInteger(Number(val))) {\n      return new IntValue(Number(val));\n    } else if (!isNaN(val)) {\n      return new FloatValue(Number(val));\n    } else if (val instanceof Path) {\n      return new DivertTargetValue(asOrThrows(val, Path));\n    } else if (val instanceof InkList) {\n      return new ListValue(asOrThrows(val, InkList));\n    }\n\n    return null;\n  }\n  public Copy() {\n    return asOrThrows(AbstractValue.Create(this.valueObject), InkObject);\n  }\n  public BadCastException(targetType: ValueType) {\n    return new StoryException(\n      \"Can't cast \" +\n        this.valueObject +\n        \" from \" +\n        this.valueType +\n        \" to \" +\n        targetType\n    );\n  }\n}\n\nexport abstract class Value<\n  T extends { toString: () => string }\n> extends AbstractValue {\n  public value: T | null;\n\n  constructor(val: T | null) {\n    super();\n    this.value = val;\n  }\n  public get valueObject() {\n    return this.value;\n  }\n  public toString() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.toString();\n  }\n}\n\nexport class BoolValue extends Value<boolean> {\n  constructor(val: boolean) {\n    super(val || false);\n  }\n  public get isTruthy() {\n    return Boolean(this.value);\n  }\n  public get valueType() {\n    return ValueType.Bool;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value ? 1 : 0);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value ? 1.0 : 0.0);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(this.value ? \"true\" : \"false\");\n    }\n\n    throw this.BadCastException(newType);\n  }\n\n  public toString() {\n    return this.value ? \"true\" : \"false\";\n  }\n}\n\nexport class IntValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0);\n  }\n  public get isTruthy() {\n    return this.value != 0;\n  }\n  public get valueType() {\n    return ValueType.Int;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0 ? false : true);\n    }\n\n    if (newType == ValueType.Float) {\n      return new FloatValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class FloatValue extends Value<number> {\n  constructor(val: number) {\n    super(val || 0.0);\n  }\n  public get isTruthy() {\n    return this.value != 0.0;\n  }\n  public get valueType() {\n    return ValueType.Float;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Bool) {\n      return new BoolValue(this.value === 0.0 ? false : true);\n    }\n\n    if (newType == ValueType.Int) {\n      return new IntValue(this.value);\n    }\n\n    if (newType == ValueType.String) {\n      return new StringValue(\"\" + this.value);\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class StringValue extends Value<string> {\n  public _isNewline: boolean;\n  public _isInlineWhitespace: boolean;\n\n  constructor(val: string) {\n    super(val || \"\");\n\n    this._isNewline = this.value == \"\\n\";\n    this._isInlineWhitespace = true;\n\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (this.value.length > 0) {\n      this.value.split(\"\").every((c) => {\n        if (c != \" \" && c != \"\\t\") {\n          this._isInlineWhitespace = false;\n          return false;\n        }\n\n        return true;\n      });\n    }\n  }\n  public get valueType() {\n    return ValueType.String;\n  }\n  public get isTruthy() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value.length > 0;\n  }\n  public get isNewline() {\n    return this._isNewline;\n  }\n  public get isInlineWhitespace() {\n    return this._isInlineWhitespace;\n  }\n  public get isNonWhitespace() {\n    return !this.isNewline && !this.isInlineWhitespace;\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) {\n      return this;\n    }\n\n    if (newType == ValueType.Int) {\n      let parsedInt = tryParseInt(this.value);\n      if (parsedInt.exists) {\n        return new IntValue(parsedInt.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    if (newType == ValueType.Float) {\n      let parsedFloat = tryParseFloat(this.value);\n      if (parsedFloat.exists) {\n        return new FloatValue(parsedFloat.result);\n      } else {\n        throw this.BadCastException(newType);\n      }\n    }\n\n    throw this.BadCastException(newType);\n  }\n}\n\nexport class DivertTargetValue extends Value<Path> {\n  constructor(targetPath: Path | null = null) {\n    super(targetPath);\n  }\n  public get valueType() {\n    return ValueType.DivertTarget;\n  }\n  public get targetPath() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set targetPath(value: Path) {\n    this.value = value;\n  }\n  public get isTruthy(): never {\n    throw new Error(\"Shouldn't be checking the truthiness of a divert target\");\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"DivertTargetValue(\" + this.targetPath + \")\";\n  }\n}\n\nexport class VariablePointerValue extends Value<string> {\n  public _contextIndex: number;\n\n  constructor(variableName: string, contextIndex: number = -1) {\n    super(variableName);\n\n    this._contextIndex = contextIndex;\n  }\n\n  public get contextIndex() {\n    return this._contextIndex;\n  }\n  public set contextIndex(value: number) {\n    this._contextIndex = value;\n  }\n  public get variableName() {\n    if (this.value === null) return throwNullException(\"Value.value\");\n    return this.value;\n  }\n  public set variableName(value: string) {\n    this.value = value;\n  }\n  public get valueType() {\n    return ValueType.VariablePointer;\n  }\n\n  public get isTruthy(): never {\n    throw new Error(\n      \"Shouldn't be checking the truthiness of a variable pointer\"\n    );\n  }\n\n  public Cast(newType: ValueType): Value<any> {\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  public toString() {\n    return \"VariablePointerValue(\" + this.variableName + \")\";\n  }\n  public Copy() {\n    return new VariablePointerValue(this.variableName, this.contextIndex);\n  }\n}\n\nexport class ListValue extends Value<InkList> {\n  public get isTruthy() {\n    if (this.value === null) {\n      return throwNullException(\"this.value\");\n    }\n    return this.value.Count > 0;\n  }\n  public get valueType() {\n    return ValueType.List;\n  }\n  public Cast(newType: ValueType): Value<any> {\n    if (this.value === null) return throwNullException(\"Value.value\");\n\n    if (newType == ValueType.Int) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new IntValue(0);\n      else return new IntValue(max.Value);\n    } else if (newType == ValueType.Float) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new FloatValue(0.0);\n      else return new FloatValue(max.Value);\n    } else if (newType == ValueType.String) {\n      let max = this.value.maxItem;\n      if (max.Key.isNull) return new StringValue(\"\");\n      else {\n        return new StringValue(max.Key.toString());\n      }\n    }\n\n    if (newType == this.valueType) return this;\n\n    throw this.BadCastException(newType);\n  }\n  constructor();\n  constructor(list: InkList);\n  constructor(listOrSingleItem: InkListItem, singleValue: number);\n  constructor(listOrSingleItem?: InkListItem | InkList, singleValue?: number) {\n    super(null);\n\n    if (!listOrSingleItem && !singleValue) {\n      this.value = new InkList();\n    } else if (listOrSingleItem instanceof InkList) {\n      this.value = new InkList(listOrSingleItem);\n    } else if (\n      listOrSingleItem instanceof InkListItem &&\n      typeof singleValue === \"number\"\n    ) {\n      this.value = new InkList({\n        Key: listOrSingleItem,\n        Value: singleValue,\n      });\n    }\n  }\n  public static RetainListOriginsForAssignment(\n    oldValue: InkObject | null,\n    newValue: InkObject\n  ) {\n    let oldList = asOrNull(oldValue, ListValue);\n    let newList = asOrNull(newValue, ListValue);\n\n    if (newList && newList.value === null)\n      return throwNullException(\"newList.value\");\n    if (oldList && oldList.value === null)\n      return throwNullException(\"oldList.value\");\n\n    // When assigning the empty list, try to retain any initial origin names\n    if (oldList && newList && newList.value!.Count == 0)\n      newList.value!.SetInitialOriginNames(oldList.value!.originNames);\n  }\n}\n\nexport enum ValueType {\n  Bool = -1,\n  Int = 0,\n  Float = 1,\n  List = 2,\n  String = 3,\n  DivertTarget = 4,\n  VariablePointer = 5,\n}\n","export enum PushPopType {\n  Tunnel = 0,\n  Function = 1,\n  FunctionEvaluationFromGame = 2,\n}\n","// TODO: Unify with Compiler.\n\nexport type ErrorHandler = (message: string, type: ErrorType) => void;\n\nexport enum ErrorType {\n  Author,\n  Warning,\n  Error,\n}\n","import { INamedContent } from \"./INamedContent\";\n\nexport function asOrNull<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | null {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    return null;\n  }\n}\n\nexport function asOrThrows<T>(\n  obj: any,\n  type: (new (...arg: any[]) => T) | (Function & { prototype: T })\n): T | never {\n  if (obj instanceof type) {\n    return unsafeTypeAssertion(obj, type);\n  } else {\n    throw new Error(`${obj} is not of type ${type}`);\n  }\n}\n\nexport function asNumberOrThrows(obj: any) {\n  if (typeof obj === \"number\") {\n    return obj as number;\n  } else {\n    throw new Error(`${obj} is not a number`);\n  }\n}\n\nexport function asBooleanOrThrows(obj: any) {\n  if (typeof obj === \"boolean\") {\n    return obj as boolean;\n  } else {\n    throw new Error(`${obj} is not a boolean`);\n  }\n}\n\n// So here, in the reference implementation, contentObj is casted to an INamedContent\n// but here we use js-style duck typing: if it implements the same props as the interface,\n// we treat it as valid.\nexport function asINamedContentOrNull(obj: any): INamedContent | null {\n  if (obj.hasValidName && obj.name) {\n    return obj as INamedContent;\n  }\n\n  return null;\n}\n\nexport function nullIfUndefined<T>(obj: T | undefined): T | null {\n  if (typeof obj === \"undefined\") {\n    return null;\n  }\n\n  return obj;\n}\n\nexport function isEquatable(type: any) {\n  return typeof type === \"object\" && typeof type.Equals === \"function\";\n}\n\nfunction unsafeTypeAssertion<T>(\n  obj: any,\n  type: (new () => T) | (Function & { prototype: T })\n) {\n  return obj as T;\n}\n\nexport function filterUndef<T>(element: T | undefined): element is T {\n  return element != undefined;\n}\n","/**\n * In the original C# code, a SystemException would be thrown when passing\n * null to methods expected a valid instance. Javascript has no such\n * concept, but TypeScript will not allow `null` to be passed to methods\n * explicitely requiring a valid type.\n *\n * Whenever TypeScript complain about the possibility of a `null` value,\n * check the offending value and it it's null, throw this exception using\n * `throwNullException(name: string)`.\n */\nexport class NullException extends Error {}\n\n/**\n * Throw a NullException.\n *\n * @param name a short description of the offending value (often its name within the code).\n */\nexport function throwNullException(name: string): never {\n  throw new NullException(`${name} is null or undefined`);\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { Debug } from \"./Debug\";\nimport { asOrNull, asINamedContentOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SearchResult } from \"./SearchResult\";\nimport { DebugMetadata } from \"./DebugMetadata\";\n\nexport class InkObject {\n  public parent: InkObject | null = null;\n\n  get debugMetadata(): DebugMetadata | null {\n    if (this._debugMetadata === null) {\n      if (this.parent) {\n        return this.parent.debugMetadata;\n      }\n    }\n\n    return this._debugMetadata;\n  }\n\n  set debugMetadata(value) {\n    this._debugMetadata = value;\n  }\n\n  get ownDebugMetadata() {\n    return this._debugMetadata;\n  }\n\n  private _debugMetadata: DebugMetadata | null = null;\n\n  public DebugLineNumberOfPath(path: Path) {\n    if (path === null) return null;\n\n    // Try to get a line number from debug metadata\n    let root = this.rootContentContainer;\n    if (root) {\n      let targetContent = root.ContentAtPath(path).obj;\n      if (targetContent) {\n        let dm = targetContent.debugMetadata;\n        if (dm !== null) {\n          return dm.startLineNumber;\n        }\n      }\n    }\n\n    return null;\n  }\n\n  get path() {\n    if (this._path == null) {\n      if (this.parent == null) {\n        this._path = new Path();\n      } else {\n        let comps: Path.Component[] = [];\n\n        let child: InkObject = this;\n        let container = asOrNull(child.parent, Container);\n\n        while (container !== null) {\n          let namedChild = asINamedContentOrNull(child);\n          if (namedChild != null && namedChild.hasValidName) {\n            if (namedChild.name === null)\n              return throwNullException(\"namedChild.name\");\n            comps.unshift(new Path.Component(namedChild.name!));\n          } else {\n            comps.unshift(new Path.Component(container.content.indexOf(child)));\n          }\n\n          child = container;\n          container = asOrNull(container.parent, Container);\n        }\n\n        this._path = new Path(comps);\n      }\n    }\n\n    return this._path;\n  }\n  private _path: Path | null = null;\n\n  public ResolvePath(path: Path | null): SearchResult {\n    if (path === null) return throwNullException(\"path\");\n    if (path.isRelative) {\n      let nearestContainer = asOrNull(this, Container);\n\n      if (nearestContainer === null) {\n        Debug.Assert(\n          this.parent !== null,\n          \"Can't resolve relative path because we don't have a parent\"\n        );\n        nearestContainer = asOrNull(this.parent, Container);\n        Debug.Assert(\n          nearestContainer !== null,\n          \"Expected parent to be a container\"\n        );\n        Debug.Assert(path.GetComponent(0).isParent);\n        path = path.tail;\n      }\n\n      if (nearestContainer === null) {\n        return throwNullException(\"nearestContainer\");\n      }\n      return nearestContainer.ContentAtPath(path);\n    } else {\n      let contentContainer = this.rootContentContainer;\n      if (contentContainer === null) {\n        return throwNullException(\"contentContainer\");\n      }\n      return contentContainer.ContentAtPath(path);\n    }\n  }\n\n  public ConvertPathToRelative(globalPath: Path) {\n    let ownPath = this.path;\n\n    let minPathLength = Math.min(globalPath.length, ownPath.length);\n    let lastSharedPathCompIndex = -1;\n\n    for (let i = 0; i < minPathLength; ++i) {\n      let ownComp = ownPath.GetComponent(i);\n      let otherComp = globalPath.GetComponent(i);\n\n      if (ownComp.Equals(otherComp)) {\n        lastSharedPathCompIndex = i;\n      } else {\n        break;\n      }\n    }\n\n    // No shared path components, so just use global path\n    if (lastSharedPathCompIndex == -1) return globalPath;\n\n    let numUpwardsMoves = ownPath.componentCount - 1 - lastSharedPathCompIndex;\n\n    let newPathComps: Path.Component[] = [];\n\n    for (let up = 0; up < numUpwardsMoves; ++up)\n      newPathComps.push(Path.Component.ToParent());\n\n    for (\n      let down = lastSharedPathCompIndex + 1;\n      down < globalPath.componentCount;\n      ++down\n    )\n      newPathComps.push(globalPath.GetComponent(down));\n\n    let relativePath = new Path(newPathComps, true);\n    return relativePath;\n  }\n\n  public CompactPathString(otherPath: Path) {\n    let globalPathStr = null;\n    let relativePathStr = null;\n\n    if (otherPath.isRelative) {\n      relativePathStr = otherPath.componentsString;\n      globalPathStr = this.path.PathByAppendingPath(otherPath).componentsString;\n    } else {\n      let relativePath = this.ConvertPathToRelative(otherPath);\n      relativePathStr = relativePath.componentsString;\n      globalPathStr = otherPath.componentsString;\n    }\n\n    if (relativePathStr.length < globalPathStr.length) return relativePathStr;\n    else return globalPathStr;\n  }\n\n  get rootContentContainer() {\n    let ancestor: InkObject = this;\n    while (ancestor.parent) {\n      ancestor = ancestor.parent;\n    }\n    return asOrNull(ancestor, Container);\n  }\n\n  public Copy(): InkObject {\n    throw Error(\"Not Implemented: Doesn't support copying\");\n  }\n  // SetChild works slightly diferently in the js implementation.\n  // Since we can't pass an objets property by reference, we instead pass\n  // the object and the property string.\n  // TODO: This method can probably be rewritten with type-safety in mind.\n  public SetChild(obj: any, prop: any, value: any) {\n    if (obj[prop]) obj[prop] = null;\n\n    obj[prop] = value;\n\n    if (obj[prop]) obj[prop].parent = this;\n  }\n\n  public Equals(obj: any) {\n    return obj === this;\n  }\n}\n","export class StringBuilder {\n  private string: string;\n\n  constructor(str?: string) {\n    str = typeof str !== \"undefined\" ? str.toString() : \"\";\n    this.string = str;\n  }\n  get Length(): number {\n    return this.string.length;\n  }\n  public Append(str: string | null) {\n    if (str !== null) {\n      this.string += str;\n    }\n  }\n  public AppendLine(str?: string) {\n    if (typeof str !== \"undefined\") this.Append(str);\n    this.string += \"\\n\";\n  }\n  public AppendFormat(format: string, ...args: any[]) {\n    // taken from http://stackoverflow.com/questions/610406/javascript-equivalent-to-printf-string-format\n    this.string += format.replace(/{(\\d+)}/g, (match: string, num: number) =>\n      typeof args[num] != \"undefined\" ? args[num] : match\n    );\n  }\n  public toString(): string {\n    return this.string;\n  }\n\n  public Clear() {\n    this.string = \"\";\n  }\n}\n","import { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Story } from \"./Story\";\n\nexport class InkListItem implements IInkListItem {\n  // InkListItem is a struct\n\n  public readonly originName: string | null = null;\n  public readonly itemName: string | null = null;\n\n  constructor(originName: string | null, itemName: string | null);\n  constructor(fullName: string | null);\n  constructor() {\n    if (typeof arguments[1] !== \"undefined\") {\n      let originName = arguments[0] as string | null;\n      let itemName = arguments[1] as string | null;\n\n      this.originName = originName;\n      this.itemName = itemName;\n    } else if (arguments[0]) {\n      let fullName = arguments[0] as string;\n\n      let nameParts = fullName.toString().split(\".\");\n      this.originName = nameParts[0];\n      this.itemName = nameParts[1];\n    }\n  }\n  public static get Null() {\n    return new InkListItem(null, null);\n  }\n  public get isNull() {\n    return this.originName == null && this.itemName == null;\n  }\n  get fullName() {\n    return (\n      (this.originName !== null ? this.originName : \"?\") + \".\" + this.itemName\n    );\n  }\n  public toString(): string {\n    return this.fullName;\n  }\n  public Equals(obj: InkListItem) {\n    if (obj instanceof InkListItem) {\n      let otherItem = obj;\n      return (\n        otherItem.itemName == this.itemName &&\n        otherItem.originName == this.originName\n      );\n    }\n\n    return false;\n  }\n\n  // These methods did not exist in the original C# code. Their purpose is to\n  // make `InkListItem` mimics the value-type semantics of the original\n  // struct. Please refer to the end of this file, for a more in-depth\n  // explanation.\n\n  /**\n   * Returns a shallow clone of the current instance.\n   */\n  public copy() {\n    return new InkListItem(this.originName, this.itemName);\n  }\n  /**\n   * Returns a `SerializedInkListItem` representing the current\n   * instance. The result is intended to be used as a key inside a Map.\n   */\n  public serialized(): SerializedInkListItem {\n    // We are simply using a JSON representation as a value-typed key.\n    return JSON.stringify({\n      originName: this.originName,\n      itemName: this.itemName,\n    });\n  }\n\n  /**\n   * Reconstructs a `InkListItem` from the given SerializedInkListItem.\n   */\n  public static fromSerializedKey(key: SerializedInkListItem): InkListItem {\n    let obj = JSON.parse(key);\n    if (!InkListItem.isLikeInkListItem(obj)) return InkListItem.Null;\n\n    let inkListItem = obj as IInkListItem;\n\n    return new InkListItem(inkListItem.originName, inkListItem.itemName);\n  }\n\n  /**\n   * Determines whether the given item is sufficiently `InkListItem`-like\n   * to be used as a template when reconstructing the InkListItem.\n   */\n  private static isLikeInkListItem(item: any) {\n    if (typeof item !== \"object\") return false;\n    if (!item.hasOwnProperty(\"originName\") || !item.hasOwnProperty(\"itemName\"))\n      return false;\n    if (typeof item.originName !== \"string\" && typeof item.originName !== null)\n      return false;\n    if (typeof item.itemName !== \"string\" && typeof item.itemName !== null)\n      return false;\n\n    return true;\n  }\n}\n\nexport class InkList extends Map<SerializedInkListItem, number> {\n  public origins: ListDefinition[] | null = null;\n  public _originNames: string[] | null = [];\n\n  constructor();\n  constructor(otherList: InkList);\n  constructor(singleOriginListName: string, originStory: Story);\n  constructor(singleElement: KeyValuePair<InkListItem, number>);\n  constructor() {\n    // Trying to be smart here, this emulates the constructor inheritance found\n    // in the original code, but only if otherList is an InkList. IIFE FTW.\n    super(\n      (() => {\n        if (arguments[0] instanceof InkList) {\n          return arguments[0];\n        } else {\n          return [];\n        }\n      })()\n    );\n\n    if (arguments[0] instanceof InkList) {\n      let otherList = arguments[0] as InkList;\n\n      let otherOriginNames = otherList.originNames as string[];\n      if (otherOriginNames !== null)\n        this._originNames = otherOriginNames.slice();\n      if (otherList.origins !== null) {\n        this.origins = otherList.origins.slice();\n      }\n    } else if (typeof arguments[0] === \"string\") {\n      let singleOriginListName = arguments[0] as string;\n      let originStory = arguments[1] as Story;\n      this.SetInitialOriginName(singleOriginListName);\n\n      if (originStory.listDefinitions === null) {\n        return throwNullException(\"originStory.listDefinitions\");\n      }\n      let def = originStory.listDefinitions.TryListGetDefinition(\n        singleOriginListName,\n        null\n      );\n      if (def.exists) {\n        // Throwing now, because if the value is `null` it will\n        // eventually throw down the line.\n        if (def.result === null) {\n          return throwNullException(\"def.result\");\n        }\n        this.origins = [def.result];\n      } else {\n        throw new Error(\n          \"InkList origin could not be found in story when constructing new list: \" +\n            singleOriginListName\n        );\n      }\n    } else if (\n      typeof arguments[0] === \"object\" &&\n      arguments[0].hasOwnProperty(\"Key\") &&\n      arguments[0].hasOwnProperty(\"Value\")\n    ) {\n      let singleElement = arguments[0] as KeyValuePair<InkListItem, number>;\n      this.Add(singleElement.Key, singleElement.Value);\n    }\n  }\n\n  public static FromString(myListItem: string, originStory: Story) {\n    let listValue =\n      originStory.listDefinitions?.FindSingleItemListWithName(myListItem);\n    if (listValue) {\n      if (listValue.value === null) {\n        return throwNullException(\"listValue.value\");\n      }\n      return new InkList(listValue.value);\n    } else {\n      throw new Error(\n        \"Could not find the InkListItem from the string '\" +\n          myListItem +\n          \"' to create an InkList because it doesn't exist in the original list definition in ink.\"\n      );\n    }\n  }\n\n  public AddItem(itemOrItemName: InkListItem | string | null) {\n    if (itemOrItemName instanceof InkListItem) {\n      let item = itemOrItemName;\n\n      if (item.originName == null) {\n        this.AddItem(item.itemName);\n        return;\n      }\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (origin.name == item.originName) {\n          let intVal = origin.TryGetValueForItem(item, 0);\n          if (intVal.exists) {\n            this.Add(item, intVal.result);\n            return;\n          } else {\n            throw new Error(\n              \"Could not add the item \" +\n                item +\n                \" to this list because it doesn't exist in the original list definition in ink.\"\n            );\n          }\n        }\n      }\n\n      throw new Error(\n        \"Failed to add item to list because the item was from a new list definition that wasn't previously known to this list. Only items from previously known lists can be used, so that the int value can be found.\"\n      );\n    } else {\n      let itemName = itemOrItemName as string | null;\n\n      let foundListDef: ListDefinition | null = null;\n\n      if (this.origins === null) return throwNullException(\"this.origins\");\n\n      for (let origin of this.origins) {\n        if (itemName === null) return throwNullException(\"itemName\");\n\n        if (origin.ContainsItemWithName(itemName)) {\n          if (foundListDef != null) {\n            throw new Error(\n              \"Could not add the item \" +\n                itemName +\n                \" to this list because it could come from either \" +\n                origin.name +\n                \" or \" +\n                foundListDef.name\n            );\n          } else {\n            foundListDef = origin;\n          }\n        }\n      }\n\n      if (foundListDef == null)\n        throw new Error(\n          \"Could not add the item \" +\n            itemName +\n            \" to this list because it isn't known to any list definitions previously associated with this list.\"\n        );\n\n      let item = new InkListItem(foundListDef.name, itemName);\n      let itemVal = foundListDef.ValueForItem(item);\n      this.Add(item, itemVal);\n    }\n  }\n  public ContainsItemNamed(itemName: string | null) {\n    for (let [key] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (item.itemName == itemName) return true;\n    }\n\n    return false;\n  }\n  public ContainsKey(key: InkListItem) {\n    return this.has(key.serialized());\n  }\n  public Add(key: InkListItem, value: number) {\n    let serializedKey = key.serialized();\n    if (this.has(serializedKey)) {\n      // Throw an exception to match the C# behavior.\n      throw new Error(`The Map already contains an entry for ${key}`);\n    }\n    this.set(serializedKey, value);\n  }\n  public Remove(key: InkListItem) {\n    return this.delete(key.serialized());\n  }\n  get Count() {\n    return this.size;\n  }\n  get originOfMaxItem(): ListDefinition | null {\n    if (this.origins == null) return null;\n\n    let maxOriginName = this.maxItem.Key.originName;\n    let result = null;\n    this.origins.every((origin) => {\n      if (origin.name == maxOriginName) {\n        result = origin;\n        return false;\n      } else return true;\n    });\n\n    return result;\n  }\n  get originNames(): string[] {\n    if (this.Count > 0) {\n      if (this._originNames == null && this.Count > 0) this._originNames = [];\n      else {\n        if (!this._originNames) this._originNames = [];\n        this._originNames.length = 0;\n      }\n\n      for (let [key] of this) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.originName === null)\n          return throwNullException(\"item.originName\");\n        this._originNames.push(item.originName);\n      }\n    }\n\n    return this._originNames as string[];\n  }\n  public SetInitialOriginName(initialOriginName: string) {\n    this._originNames = [initialOriginName];\n  }\n  public SetInitialOriginNames(initialOriginNames: string[]) {\n    if (initialOriginNames == null) this._originNames = null;\n    else this._originNames = initialOriginNames.slice(); // store a copy\n  }\n  get maxItem() {\n    let max: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (max.Key.isNull || value > max.Value)\n        max = { Key: item, Value: value };\n    }\n\n    return max;\n  }\n  get minItem() {\n    let min: KeyValuePair<InkListItem, number> = {\n      Key: InkListItem.Null,\n      Value: 0,\n    };\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      if (min.Key.isNull || value < min.Value) {\n        min = { Key: item, Value: value };\n      }\n    }\n    return min;\n  }\n  get inverse() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          if (!this.ContainsKey(item)) list.Add(item, value);\n        }\n      }\n    }\n    return list;\n  }\n  get all() {\n    let list = new InkList();\n    if (this.origins != null) {\n      for (let origin of this.origins) {\n        for (let [key, value] of origin.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          list.set(item.serialized(), value);\n        }\n      }\n    }\n    return list;\n  }\n  public Union(otherList: InkList) {\n    let union = new InkList(this);\n    for (let [key, value] of otherList) {\n      union.set(key, value);\n    }\n    return union;\n  }\n  public Intersect(otherList: InkList) {\n    let intersection = new InkList();\n    for (let [key, value] of this) {\n      if (otherList.has(key)) intersection.set(key, value);\n    }\n\n    return intersection;\n  }\n  public HasIntersection(otherList: InkList): boolean {\n    for (let [key] of this) {\n      if (otherList.has(key)) return true;\n    }\n    return false;\n  }\n  public Without(listToRemove: InkList) {\n    let result = new InkList(this);\n    for (let [key] of listToRemove) {\n      result.delete(key);\n    }\n\n    return result;\n  }\n\n  public Contains(key: string): boolean;\n  public Contains(otherList: InkList): boolean;\n  public Contains(what: string | InkList): boolean {\n    if (typeof what == \"string\") return this.ContainsItemNamed(what);\n    const otherList = what;\n    if (otherList.size == 0 || this.size == 0) return false;\n    for (let [key] of otherList) {\n      if (!this.has(key)) return false;\n    }\n\n    return true;\n  }\n  public GreaterThan(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return this.minItem.Value > otherList.maxItem.Value;\n  }\n  public GreaterThanOrEquals(otherList: InkList) {\n    if (this.Count == 0) return false;\n    if (otherList.Count == 0) return true;\n\n    return (\n      this.minItem.Value >= otherList.minItem.Value &&\n      this.maxItem.Value >= otherList.maxItem.Value\n    );\n  }\n  public LessThan(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return this.maxItem.Value < otherList.minItem.Value;\n  }\n  public LessThanOrEquals(otherList: InkList) {\n    if (otherList.Count == 0) return false;\n    if (this.Count == 0) return true;\n\n    return (\n      this.maxItem.Value <= otherList.maxItem.Value &&\n      this.minItem.Value <= otherList.minItem.Value\n    );\n  }\n  public MaxAsList() {\n    if (this.Count > 0) return new InkList(this.maxItem);\n    else return new InkList();\n  }\n  public MinAsList() {\n    if (this.Count > 0) return new InkList(this.minItem);\n    else return new InkList();\n  }\n  public ListWithSubRange(minBound: any, maxBound: any) {\n    if (this.Count == 0) return new InkList();\n\n    let ordered = this.orderedItems;\n\n    let minValue = 0;\n    let maxValue = Number.MAX_SAFE_INTEGER;\n\n    if (Number.isInteger(minBound)) {\n      minValue = minBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        minValue = minBound.minItem.Value;\n    }\n\n    if (Number.isInteger(maxBound)) {\n      maxValue = maxBound;\n    } else {\n      if (minBound instanceof InkList && minBound.Count > 0)\n        maxValue = maxBound.maxItem.Value;\n    }\n\n    let subList = new InkList();\n    subList.SetInitialOriginNames(this.originNames);\n    for (let item of ordered) {\n      if (item.Value >= minValue && item.Value <= maxValue) {\n        subList.Add(item.Key, item.Value);\n      }\n    }\n\n    return subList;\n  }\n  public Equals(otherInkList: InkList) {\n    if (otherInkList instanceof InkList === false) return false;\n    if (otherInkList.Count != this.Count) return false;\n\n    for (let [key] of this) {\n      if (!otherInkList.has(key)) return false;\n    }\n\n    return true;\n  }\n  // GetHashCode not implemented\n  get orderedItems() {\n    // List<KeyValuePair<InkListItem, int>>\n    let ordered = new Array<KeyValuePair<InkListItem, number>>();\n\n    for (let [key, value] of this) {\n      let item = InkListItem.fromSerializedKey(key);\n      ordered.push({ Key: item, Value: value });\n    }\n\n    ordered.sort((x, y) => {\n      if (x.Key.originName === null) {\n        return throwNullException(\"x.Key.originName\");\n      }\n      if (y.Key.originName === null) {\n        return throwNullException(\"y.Key.originName\");\n      }\n\n      if (x.Value == y.Value) {\n        return x.Key.originName.localeCompare(y.Key.originName);\n      } else {\n        // TODO: refactor this bit into a numberCompareTo method?\n        if (x.Value < y.Value) return -1;\n        return x.Value > y.Value ? 1 : 0;\n      }\n    });\n\n    return ordered;\n  }\n  public toString() {\n    let ordered = this.orderedItems;\n\n    let sb = new StringBuilder();\n    for (let i = 0; i < ordered.length; i++) {\n      if (i > 0) sb.Append(\", \");\n\n      let item = ordered[i].Key;\n      if (item.itemName === null) return throwNullException(\"item.itemName\");\n      sb.Append(item.itemName);\n    }\n\n    return sb.toString();\n  }\n  // casting a InkList to a Number, for somereason, actually gives a number.\n  // This messes up the type detection when creating a Value from a InkList.\n  // Returning NaN here prevents that.\n  public valueOf() {\n    return NaN;\n  }\n}\n\n/**\n * In the original C# code, `InkListItem` was defined as value type, meaning\n * that two `InkListItem` would be considered equal as long as they held the\n * same values. This doesn't hold true in Javascript, as `InkListItem` is a\n * reference type (Javascript doesn't allow the creation of custom value types).\n *\n * The key equality of Map objects is based on the \"SameValueZero\" algorithm;\n * since `InkListItem` is a value type, two keys will only be considered\n * equal if they are, in fact, the same object. As we are trying to emulate\n * the original behavior as close as possible, this will lead to unforeseen\n * side effects.\n *\n * In order to have a key equality based on value semantics, we'll convert\n * `InkListItem` to a valid string representation and use this representation\n * as a key (strings are value types in Javascript). Rather than using the\n * type `string` directly, we'll alias it to `SerializedInkListItem` and use\n * this type as the key for our Map-based `InkList`.\n *\n * Reducing `InkListItem` to a JSON representation would not be bulletproof\n * in the general case, but for our needs it works well. The major downside of\n * this method is that we will have to to reconstruct the original `InkListItem`\n * every time we'll need to access its properties.\n */\nexport type SerializedInkListItem = string;\n\n/**\n * An interface inherited by `InkListItem`, defining exposed\n * properties. It's mainly used when deserializing a `InkListItem` from its\n * key (`SerializedInkListItem`)\n */\ninterface IInkListItem {\n  readonly originName: string | null;\n  readonly itemName: string | null;\n}\nexport interface KeyValuePair<K, V> {\n  Key: K;\n  Value: V;\n}\n","export class StoryException extends Error {\n  public useEndLineNumber: boolean;\n  public message: string;\n  public name: string;\n\n  constructor(message: string) {\n    super(message);\n    this.useEndLineNumber = false;\n    this.message = message;\n    this.name = \"StoryException\";\n  }\n}\n","/**\n * This interface normalize the `TryGet` behavior found in the original\n * C# project. Any `TryGet` method will return a object conforming to this\n * interface.\n *\n * The original function returns a boolean and has a second parameter called\n * item that is an `out`. Both are needed and we can't just return the item\n * because it'll always be truthy. Instead, we return an object containing\n * whether the result exists (`exists`) and the result itself (`result`).\n *\n * For instance a `TryGet` prototype would look like this:\n```\nTryGetItemWithValue(val: number, item: InkListItem): TryGetResult<InkListItem>{\n```\n *\n * On the other hand, dealing with the result can be done in the following way:\n```\nvar item = item.TryGetItemWithValue(intVal, InkListItem.Null);\nif (item.exists) {\n\tconsole.log(item.result)\n}\n```\n *\n */\nexport interface TryGetResult<T> {\n  result: T;\n  exists: boolean;\n}\n\nexport function tryGetValueFromMap<K, V>(\n  map: Map<K, V> | null,\n  key: K,\n  /* out */ value: V\n): TryGetResult<V> {\n  if (map === null) {\n    return { result: value, exists: false };\n  }\n\n  let val = map.get(key);\n\n  if (typeof val === \"undefined\") {\n    return { result: value, exists: false };\n  } else {\n    return { result: val, exists: true };\n  }\n}\n\nexport function tryParseInt(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseInt(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n\nexport function tryParseFloat(\n  value: any,\n  /* out */ defaultValue: number = 0\n): TryGetResult<number> {\n  let val = parseFloat(value);\n\n  if (!Number.isNaN(val)) {\n    return { result: val, exists: true };\n  } else {\n    return { result: defaultValue, exists: false };\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class SearchResult {\n  public obj: InkObject | null = null;\n  public approximate: boolean = false;\n\n  get correctObj() {\n    return this.approximate ? null : this.obj;\n  }\n\n  get container() {\n    return this.obj instanceof Container ? this.obj : null;\n  }\n\n  public copy() {\n    let searchResult = new SearchResult();\n    searchResult.obj = this.obj;\n    searchResult.approximate = this.approximate;\n\n    return searchResult;\n  }\n}\n","import { StringValue } from \"./Value\";\nimport { throwNullException } from \"./NullException\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { INamedContent } from \"./INamedContent\";\nimport { InkObject } from \"./Object\";\nimport { SearchResult } from \"./SearchResult\";\nimport { Path } from \"./Path\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { asINamedContentOrNull, asOrNull, asOrThrows } from \"./TypeAssertion\";\n\nexport class Container extends InkObject implements INamedContent {\n  public name: string | null = null;\n\n  public _content: InkObject[] = [];\n  public namedContent: Map<string, INamedContent> = new Map();\n\n  public visitsShouldBeCounted: boolean = false;\n  public turnIndexShouldBeCounted: boolean = false;\n  public countingAtStartOnly: boolean = false;\n\n  public _pathToFirstLeafContent: Path | null = null;\n\n  get hasValidName() {\n    return this.name != null && this.name.length > 0;\n  }\n  get content() {\n    return this._content;\n  }\n  set content(value: InkObject[]) {\n    this.AddContent(value);\n  }\n  get namedOnlyContent() {\n    let namedOnlyContentDict: Map<string, InkObject> | null = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      let inkObject = asOrThrows(value, InkObject);\n      namedOnlyContentDict.set(key, inkObject);\n    }\n\n    for (let c of this.content) {\n      let named = asINamedContentOrNull(c);\n      if (named != null && named.hasValidName) {\n        namedOnlyContentDict.delete(named.name!);\n      }\n    }\n\n    if (namedOnlyContentDict.size == 0) namedOnlyContentDict = null;\n\n    return namedOnlyContentDict;\n  }\n  set namedOnlyContent(value: Map<string, InkObject> | null) {\n    let existingNamedOnly = this.namedOnlyContent;\n    if (existingNamedOnly != null) {\n      for (let [key] of existingNamedOnly) {\n        this.namedContent.delete(key);\n      }\n    }\n\n    if (value == null) return;\n\n    for (let [, val] of value) {\n      let named = asINamedContentOrNull(val);\n      if (named != null) this.AddToNamedContentOnly(named);\n    }\n  }\n  get countFlags(): number {\n    let flags: Container.CountFlags = 0;\n    if (this.visitsShouldBeCounted) flags |= Container.CountFlags.Visits;\n    if (this.turnIndexShouldBeCounted) flags |= Container.CountFlags.Turns;\n    if (this.countingAtStartOnly) flags |= Container.CountFlags.CountStartOnly;\n\n    if (flags == Container.CountFlags.CountStartOnly) {\n      flags = 0;\n    }\n\n    return flags;\n  }\n  set countFlags(value: number) {\n    let flag: Container.CountFlags = value;\n    if ((flag & Container.CountFlags.Visits) > 0)\n      this.visitsShouldBeCounted = true;\n    if ((flag & Container.CountFlags.Turns) > 0)\n      this.turnIndexShouldBeCounted = true;\n    if ((flag & Container.CountFlags.CountStartOnly) > 0)\n      this.countingAtStartOnly = true;\n  }\n  get pathToFirstLeafContent() {\n    if (this._pathToFirstLeafContent == null)\n      this._pathToFirstLeafContent = this.path.PathByAppendingPath(\n        this.internalPathToFirstLeafContent\n      );\n\n    return this._pathToFirstLeafContent;\n  }\n  get internalPathToFirstLeafContent() {\n    let components: Path.Component[] = [];\n    let container: Container = this;\n    while (container instanceof Container) {\n      if (container.content.length > 0) {\n        components.push(new Path.Component(0));\n        container = container.content[0] as Container;\n      }\n    }\n    return new Path(components);\n  }\n\n  public AddContent(contentObjOrList: InkObject | InkObject[]) {\n    if (contentObjOrList instanceof Array) {\n      let contentList = contentObjOrList as InkObject[];\n\n      for (let c of contentList) {\n        this.AddContent(c);\n      }\n    } else {\n      let contentObj = contentObjOrList as InkObject;\n\n      this._content.push(contentObj);\n\n      if (contentObj.parent) {\n        throw new Error(\"content is already in \" + contentObj.parent);\n      }\n\n      contentObj.parent = this;\n\n      this.TryAddNamedContent(contentObj);\n    }\n  }\n  public TryAddNamedContent(contentObj: InkObject) {\n    let namedContentObj = asINamedContentOrNull(contentObj);\n    if (namedContentObj != null && namedContentObj.hasValidName) {\n      this.AddToNamedContentOnly(namedContentObj);\n    }\n  }\n  public AddToNamedContentOnly(namedContentObj: INamedContent) {\n    Debug.AssertType(\n      namedContentObj,\n      InkObject,\n      \"Can only add Runtime.Objects to a Runtime.Container\"\n    );\n    let runtimeObj = asOrThrows(namedContentObj, InkObject);\n    runtimeObj.parent = this;\n\n    if (namedContentObj.name === null)\n      return throwNullException(\"namedContentObj.name\");\n    this.namedContent.set(namedContentObj.name!, namedContentObj);\n  }\n  public ContentAtPath(\n    path: Path,\n    partialPathStart: number = 0,\n    partialPathLength: number = -1\n  ) {\n    if (partialPathLength == -1) partialPathLength = path.length;\n\n    let result = new SearchResult();\n    result.approximate = false;\n\n    let currentContainer: Container | null = this;\n    let currentObj: InkObject = this;\n\n    for (let i = partialPathStart; i < partialPathLength; ++i) {\n      let comp = path.GetComponent(i);\n      if (currentContainer == null) {\n        result.approximate = true;\n        break;\n      }\n\n      let foundObj: InkObject | null =\n        currentContainer.ContentWithPathComponent(comp);\n\n      if (foundObj == null) {\n        result.approximate = true;\n        break;\n      }\n\n      currentObj = foundObj;\n      currentContainer = asOrNull(foundObj, Container);\n    }\n\n    result.obj = currentObj;\n\n    return result;\n  }\n  public InsertContent(contentObj: InkObject, index: number) {\n    this.content.splice(index, 0, contentObj);\n\n    if (contentObj.parent) {\n      throw new Error(\"content is already in \" + contentObj.parent);\n    }\n\n    contentObj.parent = this;\n\n    this.TryAddNamedContent(contentObj);\n  }\n  public AddContentsOfContainer(otherContainer: Container) {\n    this.content.push(...otherContainer.content);\n\n    for (let obj of otherContainer.content) {\n      obj.parent = this;\n      this.TryAddNamedContent(obj);\n    }\n  }\n  public ContentWithPathComponent(component: Path.Component): InkObject | null {\n    if (component.isIndex) {\n      if (component.index >= 0 && component.index < this.content.length) {\n        return this.content[component.index];\n      } else {\n        return null;\n      }\n    } else if (component.isParent) {\n      return this.parent;\n    } else {\n      if (component.name === null) {\n        return throwNullException(\"component.name\");\n      }\n      let foundContent = tryGetValueFromMap(\n        this.namedContent,\n        component.name,\n        null\n      );\n      if (foundContent.exists) {\n        return asOrThrows(foundContent.result, InkObject);\n      } else {\n        return null;\n      }\n    }\n  }\n  public BuildStringOfHierarchy(): string;\n  public BuildStringOfHierarchy(\n    sb: StringBuilder,\n    indentation: number,\n    pointedObj: InkObject | null\n  ): string;\n  public BuildStringOfHierarchy() {\n    let sb: StringBuilder;\n    if (arguments.length == 0) {\n      sb = new StringBuilder();\n      this.BuildStringOfHierarchy(sb, 0, null);\n      return sb.toString();\n    }\n\n    sb = arguments[0] as StringBuilder;\n    let indentation = arguments[1] as number;\n    let pointedObj = arguments[2] as InkObject | null;\n\n    function appendIndentation() {\n      const spacesPerIndent = 4; // Truly const in the original code\n      for (let i = 0; i < spacesPerIndent * indentation; ++i) {\n        sb.Append(\" \");\n      }\n    }\n\n    appendIndentation();\n    sb.Append(\"[\");\n\n    if (this.hasValidName) {\n      sb.AppendFormat(\" ({0})\", this.name);\n    }\n\n    if (this == pointedObj) {\n      sb.Append(\"  <---\");\n    }\n\n    sb.AppendLine();\n\n    indentation++;\n\n    for (let i = 0; i < this.content.length; ++i) {\n      let obj = this.content[i];\n\n      if (obj instanceof Container) {\n        let container = obj as Container;\n\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n      } else {\n        appendIndentation();\n        if (obj instanceof StringValue) {\n          sb.Append('\"');\n          sb.Append(obj.toString().replace(\"\\n\", \"\\\\n\"));\n          sb.Append('\"');\n        } else {\n          sb.Append(obj.toString());\n        }\n      }\n\n      if (i != this.content.length - 1) {\n        sb.Append(\",\");\n      }\n\n      if (!(obj instanceof Container) && obj == pointedObj) {\n        sb.Append(\"  <---\");\n      }\n\n      sb.AppendLine();\n    }\n\n    let onlyNamed: Map<string, INamedContent> = new Map();\n\n    for (let [key, value] of this.namedContent) {\n      if (this.content.indexOf(asOrThrows(value, InkObject)) >= 0) {\n        continue;\n      } else {\n        onlyNamed.set(key, value);\n      }\n    }\n\n    if (onlyNamed.size > 0) {\n      appendIndentation();\n      sb.AppendLine(\"-- named: --\");\n\n      for (let [, value] of onlyNamed) {\n        Debug.AssertType(\n          value,\n          Container,\n          \"Can only print out named Containers\"\n        );\n        let container = value as Container;\n        container.BuildStringOfHierarchy(sb, indentation, pointedObj);\n        sb.AppendLine();\n      }\n    }\n\n    indentation--;\n\n    appendIndentation();\n    sb.Append(\"]\");\n  }\n}\n\nexport namespace Container {\n  export enum CountFlags {\n    Visits = 1,\n    Turns = 2,\n    CountStartOnly = 4,\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Glue extends InkObject {\n  public toString() {\n    return \"Glue\";\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class ControlCommand extends InkObject {\n  private _commandType: ControlCommand.CommandType;\n\n  get commandType(): ControlCommand.CommandType {\n    return this._commandType;\n  }\n\n  constructor(\n    commandType: ControlCommand.CommandType = ControlCommand.CommandType.NotSet\n  ) {\n    super();\n    this._commandType = commandType;\n  }\n\n  public Copy() {\n    return new ControlCommand(this.commandType);\n  }\n  public static EvalStart() {\n    return new ControlCommand(ControlCommand.CommandType.EvalStart);\n  }\n  public static EvalOutput() {\n    return new ControlCommand(ControlCommand.CommandType.EvalOutput);\n  }\n  public static EvalEnd() {\n    return new ControlCommand(ControlCommand.CommandType.EvalEnd);\n  }\n  public static Duplicate() {\n    return new ControlCommand(ControlCommand.CommandType.Duplicate);\n  }\n  public static PopEvaluatedValue() {\n    return new ControlCommand(ControlCommand.CommandType.PopEvaluatedValue);\n  }\n  public static PopFunction() {\n    return new ControlCommand(ControlCommand.CommandType.PopFunction);\n  }\n  public static PopTunnel() {\n    return new ControlCommand(ControlCommand.CommandType.PopTunnel);\n  }\n  public static BeginString() {\n    return new ControlCommand(ControlCommand.CommandType.BeginString);\n  }\n  public static EndString() {\n    return new ControlCommand(ControlCommand.CommandType.EndString);\n  }\n  public static NoOp() {\n    return new ControlCommand(ControlCommand.CommandType.NoOp);\n  }\n  public static ChoiceCount() {\n    return new ControlCommand(ControlCommand.CommandType.ChoiceCount);\n  }\n  public static Turns() {\n    return new ControlCommand(ControlCommand.CommandType.Turns);\n  }\n  public static TurnsSince() {\n    return new ControlCommand(ControlCommand.CommandType.TurnsSince);\n  }\n  public static ReadCount() {\n    return new ControlCommand(ControlCommand.CommandType.ReadCount);\n  }\n  public static Random() {\n    return new ControlCommand(ControlCommand.CommandType.Random);\n  }\n  public static SeedRandom() {\n    return new ControlCommand(ControlCommand.CommandType.SeedRandom);\n  }\n  public static VisitIndex() {\n    return new ControlCommand(ControlCommand.CommandType.VisitIndex);\n  }\n  public static SequenceShuffleIndex() {\n    return new ControlCommand(ControlCommand.CommandType.SequenceShuffleIndex);\n  }\n  public static StartThread() {\n    return new ControlCommand(ControlCommand.CommandType.StartThread);\n  }\n  public static Done() {\n    return new ControlCommand(ControlCommand.CommandType.Done);\n  }\n  public static End() {\n    return new ControlCommand(ControlCommand.CommandType.End);\n  }\n  public static ListFromInt() {\n    return new ControlCommand(ControlCommand.CommandType.ListFromInt);\n  }\n  public static ListRange() {\n    return new ControlCommand(ControlCommand.CommandType.ListRange);\n  }\n  public static ListRandom() {\n    return new ControlCommand(ControlCommand.CommandType.ListRandom);\n  }\n  public static BeginTag() {\n    return new ControlCommand(ControlCommand.CommandType.BeginTag);\n  }\n  public static EndTag() {\n    return new ControlCommand(ControlCommand.CommandType.EndTag);\n  }\n  public toString() {\n    return this.commandType.toString();\n  }\n}\n\nexport namespace ControlCommand {\n  export enum CommandType {\n    NotSet = -1,\n    EvalStart, // 0\n    EvalOutput, // 1\n    EvalEnd, // 2\n    Duplicate, // 3\n    PopEvaluatedValue, // 4\n    PopFunction, // 5\n    PopTunnel, // 6\n    BeginString, // 7\n    EndString, // 8\n    NoOp, // 9\n    ChoiceCount, // 10\n    Turns, // 11\n    TurnsSince, // 12\n    ReadCount, // 13\n    Random, // 14\n    SeedRandom, // 15\n    VisitIndex, // 16\n    SequenceShuffleIndex, // 17\n    StartThread, // 18\n    Done, // 19\n    End, // 20\n    ListFromInt, // 21\n    ListRange, // 22\n    ListRandom, // 23\n    BeginTag, // 24\n    EndTag, // 25\n\n    TOTAL_VALUES,\n  }\n}\n","import { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\n\nexport class Pointer {\n  public container: Container | null = null;\n  public index: number = -1;\n\n  constructor();\n  constructor(container: Container | null, index: number);\n  constructor() {\n    if (arguments.length === 2) {\n      this.container = arguments[0];\n      this.index = arguments[1];\n    }\n  }\n\n  public Resolve(): InkObject | null {\n    if (this.index < 0) return this.container;\n    if (this.container == null) return null;\n    if (this.container.content.length == 0) return this.container;\n    if (this.index >= this.container.content.length) return null;\n\n    return this.container.content[this.index];\n  }\n\n  get isNull(): boolean {\n    return this.container == null;\n  }\n\n  get path(): Path | null {\n    if (this.isNull) return null;\n\n    if (this.index >= 0)\n      return this.container!.path.PathByAppendingComponent(\n        new Path.Component(this.index)\n      );\n    else return this.container!.path;\n  }\n\n  public toString(): string {\n    if (!this.container) return \"Ink Pointer (null)\";\n\n    return (\n      \"Ink Pointer -> \" +\n      this.container.path.toString() +\n      \" -- index \" +\n      this.index\n    );\n  }\n\n  // This method does not exist in the original C# code, but is here to maintain the\n  // value semantics of Pointer.\n  public copy(): Pointer {\n    return new Pointer(this.container, this.index);\n  }\n\n  public static StartOf(container: Container | null): Pointer {\n    return new Pointer(container, 0);\n  }\n\n  public static get Null(): Pointer {\n    return new Pointer(null, -1);\n  }\n}\n","import { Path } from \"./Path\";\nimport { PushPopType } from \"./PushPop\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { InkObject } from \"./Object\";\nimport { Pointer } from \"./Pointer\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Divert extends InkObject {\n  get targetPath() {\n    if (this._targetPath != null && this._targetPath.isRelative) {\n      let targetObj = this.targetPointer.Resolve();\n      if (targetObj) {\n        this._targetPath = targetObj.path;\n      }\n    }\n\n    return this._targetPath;\n  }\n  set targetPath(value: Path | null) {\n    this._targetPath = value;\n    this._targetPointer = Pointer.Null;\n  }\n\n  public _targetPath: Path | null = null;\n\n  get targetPointer() {\n    if (this._targetPointer.isNull) {\n      let targetObj = this.ResolvePath(this._targetPath).obj;\n\n      if (this._targetPath === null)\n        return throwNullException(\"this._targetPath\");\n      if (this._targetPath.lastComponent === null)\n        return throwNullException(\"this._targetPath.lastComponent\");\n\n      if (this._targetPath.lastComponent.isIndex) {\n        if (targetObj === null) return throwNullException(\"targetObj\");\n        this._targetPointer.container =\n          targetObj.parent instanceof Container ? targetObj.parent : null;\n        this._targetPointer.index = this._targetPath.lastComponent.index;\n      } else {\n        this._targetPointer = Pointer.StartOf(\n          targetObj instanceof Container ? targetObj : null\n        );\n      }\n    }\n\n    return this._targetPointer.copy();\n  }\n\n  public _targetPointer: Pointer = Pointer.Null;\n\n  get targetPathString() {\n    if (this.targetPath == null) return null;\n\n    return this.CompactPathString(this.targetPath);\n  }\n  set targetPathString(value: string | null) {\n    if (value == null) {\n      this.targetPath = null;\n    } else {\n      this.targetPath = new Path(value);\n    }\n  }\n\n  public variableDivertName: string | null = null;\n  get hasVariableTarget() {\n    return this.variableDivertName != null;\n  }\n\n  public pushesToStack: boolean = false;\n  public stackPushType: PushPopType = 0;\n\n  public isExternal: boolean = false;\n  public externalArgs: number = 0;\n\n  public isConditional: boolean = false;\n\n  constructor(stackPushType?: PushPopType) {\n    super();\n    this.pushesToStack = false;\n\n    if (typeof stackPushType !== \"undefined\") {\n      this.pushesToStack = true;\n      this.stackPushType = stackPushType;\n    }\n  }\n\n  public Equals(obj: Divert | null) {\n    let otherDivert = obj;\n    if (otherDivert instanceof Divert) {\n      if (this.hasVariableTarget == otherDivert.hasVariableTarget) {\n        if (this.hasVariableTarget) {\n          return this.variableDivertName == otherDivert.variableDivertName;\n        } else {\n          if (this.targetPath === null)\n            return throwNullException(\"this.targetPath\");\n          return this.targetPath.Equals(otherDivert.targetPath);\n        }\n      }\n    }\n    return false;\n  }\n\n  public toString() {\n    if (this.hasVariableTarget) {\n      return \"Divert(variable: \" + this.variableDivertName + \")\";\n    } else if (this.targetPath == null) {\n      return \"Divert(null)\";\n    } else {\n      let sb = new StringBuilder();\n\n      let targetStr = this.targetPath.toString();\n      // int? targetLineNum = DebugLineNumberOfPath (targetPath);\n      let targetLineNum = null;\n      if (targetLineNum != null) {\n        targetStr = \"line \" + targetLineNum;\n      }\n\n      sb.Append(\"Divert\");\n\n      if (this.isConditional) sb.Append(\"?\");\n\n      if (this.pushesToStack) {\n        if (this.stackPushType == PushPopType.Function) {\n          sb.Append(\" function\");\n        } else {\n          sb.Append(\" tunnel\");\n        }\n      }\n\n      sb.Append(\" -> \");\n      sb.Append(this.targetPathString);\n\n      sb.Append(\" (\");\n      sb.Append(targetStr);\n      sb.Append(\")\");\n\n      return sb.toString();\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\nimport { Container } from \"./Container\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ChoicePoint extends InkObject {\n  public _pathOnChoice: Path | null = null;\n  public hasCondition: boolean = false;\n  public hasStartContent: boolean = false;\n  public hasChoiceOnlyContent: boolean = false;\n  public isInvisibleDefault: boolean = false;\n  public onceOnly: boolean = true;\n\n  constructor(onceOnly: boolean = true) {\n    super();\n    this.onceOnly = onceOnly;\n  }\n  get pathOnChoice(): Path | null {\n    if (this._pathOnChoice != null && this._pathOnChoice.isRelative) {\n      let choiceTargetObj = this.choiceTarget;\n      if (choiceTargetObj) {\n        this._pathOnChoice = choiceTargetObj.path;\n      }\n    }\n    return this._pathOnChoice;\n  }\n  set pathOnChoice(value: Path | null) {\n    this._pathOnChoice = value;\n  }\n  get choiceTarget(): Container | null {\n    if (this._pathOnChoice === null)\n      return throwNullException(\"ChoicePoint._pathOnChoice\");\n    return this.ResolvePath(this._pathOnChoice).container;\n  }\n  get pathStringOnChoice(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    return this.CompactPathString(this.pathOnChoice);\n  }\n  set pathStringOnChoice(value: string) {\n    this.pathOnChoice = new Path(value);\n  }\n  get flags(): number {\n    let flags = 0;\n    if (this.hasCondition) flags |= 1;\n    if (this.hasStartContent) flags |= 2;\n    if (this.hasChoiceOnlyContent) flags |= 4;\n    if (this.isInvisibleDefault) flags |= 8;\n    if (this.onceOnly) flags |= 16;\n    return flags;\n  }\n  set flags(value: number) {\n    this.hasCondition = (value & 1) > 0;\n    this.hasStartContent = (value & 2) > 0;\n    this.hasChoiceOnlyContent = (value & 4) > 0;\n    this.isInvisibleDefault = (value & 8) > 0;\n    this.onceOnly = (value & 16) > 0;\n  }\n  public toString(): string {\n    if (this.pathOnChoice === null)\n      return throwNullException(\"ChoicePoint.pathOnChoice\");\n    // int? targetLineNum = DebugLineNumberOfPath (pathOnChoice);\n    let targetLineNum = null;\n    let targetString = this.pathOnChoice.toString();\n\n    if (targetLineNum != null) {\n      targetString = \" line \" + targetLineNum + \"(\" + targetString + \")\";\n    }\n\n    return \"Choice: -> \" + targetString;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Path } from \"./Path\";\n\nexport class VariableReference extends InkObject {\n  public name: string | null;\n  public pathForCount: Path | null = null;\n\n  get containerForCount() {\n    if (this.pathForCount === null) return null;\n    return this.ResolvePath(this.pathForCount).container;\n  }\n  get pathStringForCount() {\n    if (this.pathForCount === null) return null;\n\n    return this.CompactPathString(this.pathForCount);\n  }\n  set pathStringForCount(value: string | null) {\n    if (value === null) this.pathForCount = null;\n    else this.pathForCount = new Path(value);\n  }\n\n  constructor(name: string | null = null) {\n    super();\n    this.name = name;\n  }\n\n  public toString() {\n    if (this.name != null) {\n      return \"var(\" + this.name + \")\";\n    } else {\n      let pathStr = this.pathStringForCount;\n      return \"read_count(\" + pathStr + \")\";\n    }\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class VariableAssignment extends InkObject {\n  public readonly variableName: string | null;\n  public readonly isNewDeclaration: boolean;\n  public isGlobal: boolean;\n\n  constructor(variableName: string | null, isNewDeclaration: boolean) {\n    super();\n    this.variableName = variableName || null;\n    this.isNewDeclaration = !!isNewDeclaration;\n    this.isGlobal = false;\n  }\n\n  public toString(): string {\n    return \"VarAssign to \" + this.variableName;\n  }\n}\n","import { InkObject } from \"./Object\";\n\nexport class Void extends InkObject {}\n","import { Value, ValueType, IntValue, ListValue, BoolValue } from \"./Value\";\nimport { StoryException } from \"./StoryException\";\nimport { Void } from \"./Void\";\nimport { Path } from \"./Path\";\nimport { InkList, InkListItem } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull, asOrThrows, asBooleanOrThrows } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\n\ntype BinaryOp<T> = (left: T, right: T) => any;\ntype UnaryOp<T> = (val: T) => any;\n\nexport class NativeFunctionCall extends InkObject {\n  public static readonly Add: string = \"+\";\n  public static readonly Subtract: string = \"-\";\n  public static readonly Divide: string = \"/\";\n  public static readonly Multiply: string = \"*\";\n  public static readonly Mod: string = \"%\";\n  public static readonly Negate: string = \"_\";\n  public static readonly Equal: string = \"==\";\n  public static readonly Greater: string = \">\";\n  public static readonly Less: string = \"<\";\n  public static readonly GreaterThanOrEquals: string = \">=\";\n  public static readonly LessThanOrEquals: string = \"<=\";\n  public static readonly NotEquals: string = \"!=\";\n  public static readonly Not: string = \"!\";\n  public static readonly And: string = \"&&\";\n  public static readonly Or: string = \"||\";\n  public static readonly Min: string = \"MIN\";\n  public static readonly Max: string = \"MAX\";\n  public static readonly Pow: string = \"POW\";\n  public static readonly Floor: string = \"FLOOR\";\n  public static readonly Ceiling: string = \"CEILING\";\n  public static readonly Int: string = \"INT\";\n  public static readonly Float: string = \"FLOAT\";\n  public static readonly Has: string = \"?\";\n  public static readonly Hasnt: string = \"!?\";\n  public static readonly Intersect: string = \"^\";\n  public static readonly ListMin: string = \"LIST_MIN\";\n  public static readonly ListMax: string = \"LIST_MAX\";\n  public static readonly All: string = \"LIST_ALL\";\n  public static readonly Count: string = \"LIST_COUNT\";\n  public static readonly ValueOfList: string = \"LIST_VALUE\";\n  public static readonly Invert: string = \"LIST_INVERT\";\n\n  public static CallWithName(functionName: string) {\n    return new NativeFunctionCall(functionName);\n  }\n\n  public static CallExistsWithName(functionName: string) {\n    this.GenerateNativeFunctionsIfNecessary();\n    return this._nativeFunctions!.get(functionName);\n  }\n\n  get name() {\n    if (this._name === null)\n      return throwNullException(\"NativeFunctionCall._name\");\n    return this._name;\n  }\n  set name(value: string) {\n    this._name = value;\n    if (!this._isPrototype) {\n      if (NativeFunctionCall._nativeFunctions === null)\n        throwNullException(\"NativeFunctionCall._nativeFunctions\");\n      else\n        this._prototype =\n          NativeFunctionCall._nativeFunctions.get(this._name) || null;\n    }\n  }\n  public _name: string | null = null;\n\n  get numberOfParameters() {\n    if (this._prototype) {\n      return this._prototype.numberOfParameters;\n    } else {\n      return this._numberOfParameters;\n    }\n  }\n  set numberOfParameters(value: number) {\n    this._numberOfParameters = value;\n  }\n  public _numberOfParameters: number = 0;\n\n  public Call(parameters: InkObject[]): InkObject | null {\n    if (this._prototype) {\n      return this._prototype.Call(parameters);\n    }\n\n    if (this.numberOfParameters != parameters.length) {\n      throw new Error(\"Unexpected number of parameters\");\n    }\n\n    let hasList = false;\n    for (let p of parameters) {\n      if (p instanceof Void)\n        throw new StoryException(\n          'Attempting to perform operation on a void value. Did you forget to \"return\" a value from a function you called here?'\n        );\n      if (p instanceof ListValue) hasList = true;\n    }\n\n    if (parameters.length == 2 && hasList) {\n      return this.CallBinaryListOperation(parameters);\n    }\n\n    let coercedParams = this.CoerceValuesToSingleType(parameters);\n    let coercedType = coercedParams[0].valueType;\n\n    if (coercedType == ValueType.Int) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.Float) {\n      return this.CallType<number>(coercedParams);\n    } else if (coercedType == ValueType.String) {\n      return this.CallType<string>(coercedParams);\n    } else if (coercedType == ValueType.DivertTarget) {\n      return this.CallType<Path>(coercedParams);\n    } else if (coercedType == ValueType.List) {\n      return this.CallType<InkList>(coercedParams);\n    }\n\n    return null;\n  }\n\n  public CallType<T>(parametersOfSingleType: Array<Value<T>>) {\n    let param1 = asOrThrows(parametersOfSingleType[0], Value);\n    let valType = param1.valueType;\n\n    let val1 = param1 as Value<T>;\n\n    let paramCount = parametersOfSingleType.length;\n\n    if (paramCount == 2 || paramCount == 1) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let opForTypeObj = this._operationFuncs.get(valType);\n      if (!opForTypeObj) {\n        const key = ValueType[valType];\n        throw new StoryException(\n          \"Cannot perform operation \" + this.name + \" on \" + key\n        );\n      }\n\n      if (paramCount == 2) {\n        let param2 = asOrThrows(parametersOfSingleType[1], Value);\n\n        let val2 = param2 as Value<T>;\n\n        let opForType = opForTypeObj as BinaryOp<T>;\n\n        if (val1.value === null || val2.value === null)\n          return throwNullException(\"NativeFunctionCall.Call BinaryOp values\");\n        let resultVal = opForType(val1.value, val2.value);\n\n        return Value.Create(resultVal);\n      } else {\n        let opForType = opForTypeObj as UnaryOp<T>;\n\n        if (val1.value === null)\n          return throwNullException(\"NativeFunctionCall.Call UnaryOp value\");\n        let resultVal = opForType(val1.value);\n\n        // This code is different from upstream. Since JavaScript treats\n        // integers and floats as the same numbers, it's impossible\n        // to force an number to be either an integer or a float.\n        //\n        // It can be useful to force a specific number type\n        // (especially for divisions), so the result of INT() & FLOAT()\n        // is coerced to the the proper value type.\n        //\n        // Note that we also force all other unary operation to\n        // return the same value type, although this is only\n        // meaningful for numbers. See `Value.Create`.\n        if (this.name === NativeFunctionCall.Int) {\n          return Value.Create(resultVal, ValueType.Int);\n        } else if (this.name === NativeFunctionCall.Float) {\n          return Value.Create(resultVal, ValueType.Float);\n        } else {\n          return Value.Create(resultVal, param1.valueType);\n        }\n      }\n    } else {\n      throw new Error(\n        \"Unexpected number of parameters to NativeFunctionCall: \" +\n          parametersOfSingleType.length\n      );\n    }\n  }\n\n  public CallBinaryListOperation(parameters: InkObject[]) {\n    if (\n      (this.name == \"+\" || this.name == \"-\") &&\n      parameters[0] instanceof ListValue &&\n      parameters[1] instanceof IntValue\n    )\n      return this.CallListIncrementOperation(parameters);\n\n    let v1 = asOrThrows(parameters[0], Value);\n    let v2 = asOrThrows(parameters[1], Value);\n\n    if (\n      (this.name == \"&&\" || this.name == \"||\") &&\n      (v1.valueType != ValueType.List || v2.valueType != ValueType.List)\n    ) {\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let op = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n      if (op === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallBinaryListOperation op\"\n        );\n      let result = asBooleanOrThrows(\n        op(v1.isTruthy ? 1 : 0, v2.isTruthy ? 1 : 0)\n      );\n      return new BoolValue(result);\n    }\n\n    if (v1.valueType == ValueType.List && v2.valueType == ValueType.List)\n      return this.CallType<InkList>([v1, v2]);\n\n    throw new StoryException(\n      \"Can not call use \" +\n        this.name +\n        \" operation on \" +\n        ValueType[v1.valueType] +\n        \" and \" +\n        ValueType[v2.valueType]\n    );\n  }\n\n  public CallListIncrementOperation(listIntParams: InkObject[]) {\n    let listVal = asOrThrows(listIntParams[0], ListValue);\n    let intVal = asOrThrows(listIntParams[1], IntValue);\n\n    let resultInkList = new InkList();\n\n    if (listVal.value === null)\n      return throwNullException(\n        \"NativeFunctionCall.CallListIncrementOperation listVal.value\"\n      );\n    for (let [listItemKey, listItemValue] of listVal.value) {\n      let listItem = InkListItem.fromSerializedKey(listItemKey);\n\n      if (this._operationFuncs === null)\n        return throwNullException(\"NativeFunctionCall._operationFuncs\");\n      let intOp = this._operationFuncs.get(ValueType.Int) as BinaryOp<number>;\n\n      if (intVal.value === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation intVal.value\"\n        );\n      let targetInt = intOp(listItemValue, intVal.value);\n\n      let itemOrigin = null;\n      if (listVal.value.origins === null)\n        return throwNullException(\n          \"NativeFunctionCall.CallListIncrementOperation listVal.value.origins\"\n        );\n      for (let origin of listVal.value.origins) {\n        if (origin.name == listItem.originName) {\n          itemOrigin = origin;\n          break;\n        }\n      }\n      if (itemOrigin != null) {\n        let incrementedItem = itemOrigin.TryGetItemWithValue(\n          targetInt,\n          InkListItem.Null\n        );\n        if (incrementedItem.exists)\n          resultInkList.Add(incrementedItem.result, targetInt);\n      }\n    }\n\n    return new ListValue(resultInkList);\n  }\n\n  public CoerceValuesToSingleType(parametersIn: InkObject[]) {\n    let valType = ValueType.Int;\n\n    let specialCaseList: null | ListValue = null;\n\n    for (let obj of parametersIn) {\n      let val = asOrThrows(obj, Value);\n      if (val.valueType > valType) {\n        valType = val.valueType;\n      }\n\n      if (val.valueType == ValueType.List) {\n        specialCaseList = asOrNull(val, ListValue);\n      }\n    }\n\n    let parametersOut = [];\n\n    if (ValueType[valType] == ValueType[ValueType.List]) {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        if (val.valueType == ValueType.List) {\n          parametersOut.push(val);\n        } else if (val.valueType == ValueType.Int) {\n          let intVal = parseInt(val.valueObject);\n\n          specialCaseList = asOrThrows(specialCaseList, ListValue);\n          if (specialCaseList.value === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType specialCaseList.value\"\n            );\n          let list = specialCaseList.value.originOfMaxItem;\n\n          if (list === null)\n            return throwNullException(\n              \"NativeFunctionCall.CoerceValuesToSingleType list\"\n            );\n          let item = list.TryGetItemWithValue(intVal, InkListItem.Null);\n          if (item.exists) {\n            let castedValue = new ListValue(item.result, intVal);\n            parametersOut.push(castedValue);\n          } else\n            throw new StoryException(\n              \"Could not find List item with the value \" +\n                intVal +\n                \" in \" +\n                list.name\n            );\n        } else {\n          const key = ValueType[val.valueType];\n          throw new StoryException(\n            \"Cannot mix Lists and \" + key + \" values in this operation\"\n          );\n        }\n      }\n    } else {\n      for (let inkObjectVal of parametersIn) {\n        let val = asOrThrows(inkObjectVal, Value);\n        let castedValue = val.Cast(valType);\n        parametersOut.push(castedValue);\n      }\n    }\n\n    return parametersOut;\n  }\n\n  constructor(name: string);\n  constructor(name: string, numberOfParameters: number);\n  constructor();\n  constructor() {\n    super();\n\n    if (arguments.length === 0) {\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n    } else if (arguments.length === 1) {\n      let name = arguments[0];\n      NativeFunctionCall.GenerateNativeFunctionsIfNecessary();\n      this.name = name;\n    } else if (arguments.length === 2) {\n      let name = arguments[0];\n      let numberOfParameters = arguments[1];\n\n      this._isPrototype = true;\n      this.name = name;\n      this.numberOfParameters = numberOfParameters;\n    }\n  }\n\n  public static Identity<T>(t: T): any {\n    return t;\n  }\n\n  public static GenerateNativeFunctionsIfNecessary() {\n    if (this._nativeFunctions == null) {\n      this._nativeFunctions = new Map();\n\n      // Int operations\n      this.AddIntBinaryOp(this.Add, (x, y) => x + y);\n      this.AddIntBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddIntBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddIntBinaryOp(this.Divide, (x, y) => Math.floor(x / y));\n      this.AddIntBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddIntUnaryOp(this.Negate, (x) => -x);\n\n      this.AddIntBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddIntBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddIntBinaryOp(this.Less, (x, y) => x < y);\n      this.AddIntBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddIntBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddIntBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddIntUnaryOp(this.Not, (x) => x == 0);\n\n      this.AddIntBinaryOp(this.And, (x, y) => x != 0 && y != 0);\n      this.AddIntBinaryOp(this.Or, (x, y) => x != 0 || y != 0);\n\n      this.AddIntBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddIntBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddIntBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddIntUnaryOp(this.Floor, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Ceiling, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Int, NativeFunctionCall.Identity);\n      this.AddIntUnaryOp(this.Float, (x) => x);\n\n      // Float operations\n      this.AddFloatBinaryOp(this.Add, (x, y) => x + y);\n      this.AddFloatBinaryOp(this.Subtract, (x, y) => x - y);\n      this.AddFloatBinaryOp(this.Multiply, (x, y) => x * y);\n      this.AddFloatBinaryOp(this.Divide, (x, y) => x / y);\n      this.AddFloatBinaryOp(this.Mod, (x, y) => x % y);\n      this.AddFloatUnaryOp(this.Negate, (x) => -x);\n\n      this.AddFloatBinaryOp(this.Equal, (x, y) => x == y);\n      this.AddFloatBinaryOp(this.Greater, (x, y) => x > y);\n      this.AddFloatBinaryOp(this.Less, (x, y) => x < y);\n      this.AddFloatBinaryOp(this.GreaterThanOrEquals, (x, y) => x >= y);\n      this.AddFloatBinaryOp(this.LessThanOrEquals, (x, y) => x <= y);\n      this.AddFloatBinaryOp(this.NotEquals, (x, y) => x != y);\n      this.AddFloatUnaryOp(this.Not, (x) => x == 0.0);\n\n      this.AddFloatBinaryOp(this.And, (x, y) => x != 0.0 && y != 0.0);\n      this.AddFloatBinaryOp(this.Or, (x, y) => x != 0.0 || y != 0.0);\n\n      this.AddFloatBinaryOp(this.Max, (x, y) => Math.max(x, y));\n      this.AddFloatBinaryOp(this.Min, (x, y) => Math.min(x, y));\n\n      this.AddFloatBinaryOp(this.Pow, (x, y) => Math.pow(x, y));\n      this.AddFloatUnaryOp(this.Floor, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Ceiling, (x) => Math.ceil(x));\n      this.AddFloatUnaryOp(this.Int, (x) => Math.floor(x));\n      this.AddFloatUnaryOp(this.Float, NativeFunctionCall.Identity);\n\n      // String operations\n      this.AddStringBinaryOp(this.Add, (x, y) => x + y); // concat\n      this.AddStringBinaryOp(this.Equal, (x, y) => x === y);\n      this.AddStringBinaryOp(this.NotEquals, (x, y) => !(x === y));\n      this.AddStringBinaryOp(this.Has, (x, y) => x.includes(y));\n      this.AddStringBinaryOp(this.Hasnt, (x, y) => !x.includes(y));\n\n      this.AddListBinaryOp(this.Add, (x, y) => x.Union(y));\n      this.AddListBinaryOp(this.Subtract, (x, y) => x.Without(y));\n      this.AddListBinaryOp(this.Has, (x, y) => x.Contains(y));\n      this.AddListBinaryOp(this.Hasnt, (x, y) => !x.Contains(y));\n      this.AddListBinaryOp(this.Intersect, (x, y) => x.Intersect(y));\n\n      this.AddListBinaryOp(this.Equal, (x, y) => x.Equals(y));\n      this.AddListBinaryOp(this.Greater, (x, y) => x.GreaterThan(y));\n      this.AddListBinaryOp(this.Less, (x, y) => x.LessThan(y));\n      this.AddListBinaryOp(this.GreaterThanOrEquals, (x, y) =>\n        x.GreaterThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.LessThanOrEquals, (x, y) =>\n        x.LessThanOrEquals(y)\n      );\n      this.AddListBinaryOp(this.NotEquals, (x, y) => !x.Equals(y));\n\n      this.AddListBinaryOp(this.And, (x, y) => x.Count > 0 && y.Count > 0);\n      this.AddListBinaryOp(this.Or, (x, y) => x.Count > 0 || y.Count > 0);\n\n      this.AddListUnaryOp(this.Not, (x) => (x.Count == 0 ? 1 : 0));\n\n      this.AddListUnaryOp(this.Invert, (x) => x.inverse);\n      this.AddListUnaryOp(this.All, (x) => x.all);\n      this.AddListUnaryOp(this.ListMin, (x) => x.MinAsList());\n      this.AddListUnaryOp(this.ListMax, (x) => x.MaxAsList());\n      this.AddListUnaryOp(this.Count, (x) => x.Count);\n      this.AddListUnaryOp(this.ValueOfList, (x) => x.maxItem.Value);\n\n      let divertTargetsEqual = (d1: Path, d2: Path) => d1.Equals(d2);\n      let divertTargetsNotEqual = (d1: Path, d2: Path) => !d1.Equals(d2);\n      this.AddOpToNativeFunc(\n        this.Equal,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsEqual\n      );\n      this.AddOpToNativeFunc(\n        this.NotEquals,\n        2,\n        ValueType.DivertTarget,\n        divertTargetsNotEqual\n      );\n    }\n  }\n\n  public AddOpFuncForType(\n    valType: ValueType,\n    op: UnaryOp<number | InkList> | BinaryOp<number | string | InkList | Path>\n  ): void {\n    if (this._operationFuncs == null) {\n      this._operationFuncs = new Map();\n    }\n\n    this._operationFuncs.set(valType, op);\n  }\n\n  public static AddOpToNativeFunc(\n    name: string,\n    args: number,\n    valType: ValueType,\n    op: UnaryOp<any> | BinaryOp<any>\n  ): void {\n    if (this._nativeFunctions === null)\n      return throwNullException(\"NativeFunctionCall._nativeFunctions\");\n    let nativeFunc = this._nativeFunctions.get(name);\n    if (!nativeFunc) {\n      nativeFunc = new NativeFunctionCall(name, args);\n      this._nativeFunctions.set(name, nativeFunc);\n    }\n\n    nativeFunc.AddOpFuncForType(valType, op);\n  }\n\n  public static AddIntBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Int, op);\n  }\n  public static AddIntUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Int, op);\n  }\n\n  public static AddFloatBinaryOp(name: string, op: BinaryOp<number>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.Float, op);\n  }\n  public static AddFloatUnaryOp(name: string, op: UnaryOp<number>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.Float, op);\n  }\n\n  public static AddStringBinaryOp(name: string, op: BinaryOp<string>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.String, op);\n  }\n\n  public static AddListBinaryOp(name: string, op: BinaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 2, ValueType.List, op);\n  }\n  public static AddListUnaryOp(name: string, op: UnaryOp<InkList>) {\n    this.AddOpToNativeFunc(name, 1, ValueType.List, op);\n  }\n\n  public toString() {\n    return 'Native \"' + this.name + '\"';\n  }\n\n  public _prototype: NativeFunctionCall | null = null;\n  public _isPrototype: boolean = false;\n  public _operationFuncs: Map<ValueType, BinaryOp<any> | UnaryOp<any>> | null =\n    null;\n  public static _nativeFunctions: Map<string, NativeFunctionCall> | null = null;\n}\n","import { InkObject } from \"./Object\";\n\n// New version of tags is dynamic - it constructs the tags\n// at runtime based on BeginTag and EndTag control commands.\n// Plain text that's in the output stream is turned into tags\n// when you do story.currentTags.\n// The only place this is used is when flattening tags down\n// to string in advance, during dynamic string generation if\n// there's a tag embedded in it. See how ControlCommand.EndString\n// is implemented in Story.cs for more details + comment\nexport class Tag extends InkObject {\n  public readonly text: string;\n\n  constructor(tagText: string) {\n    super();\n    this.text = tagText.toString() || \"\";\n  }\n\n  public toString(): string {\n    return \"# \" + this.text;\n  }\n}\n","import { Path } from \"./Path\";\nimport { CallStack } from \"./CallStack\";\nimport { throwNullException } from \"./NullException\";\nimport { InkObject } from \"./Object\";\n\nexport class Choice extends InkObject {\n  public text: string = \"\";\n  public index: number = 0;\n  public threadAtGeneration: CallStack.Thread | null = null;\n  public sourcePath: string = \"\";\n  public targetPath: Path | null = null;\n  public isInvisibleDefault: boolean = false;\n  public tags: string[] | null = null;\n  public originalThreadIndex: number = 0;\n\n  get pathStringOnChoice(): string {\n    if (this.targetPath === null)\n      return throwNullException(\"Choice.targetPath\");\n    return this.targetPath.toString();\n  }\n  set pathStringOnChoice(value: string) {\n    this.targetPath = new Path(value);\n  }\n}\n","import { InkListItem, SerializedInkListItem } from \"./InkList\";\nimport { TryGetResult } from \"./TryGetResult\";\n\nexport class ListDefinition {\n  public _name: string;\n  public _items: Map<SerializedInkListItem, number> | null;\n  public _itemNameToValues: Map<string, number>;\n\n  constructor(name: string, items: Map<string, number> | null) {\n    this._name = name || \"\";\n    this._items = null;\n    this._itemNameToValues = items || new Map();\n  }\n  get name() {\n    return this._name;\n  }\n  get items() {\n    if (this._items == null) {\n      this._items = new Map();\n      for (let [key, value] of this._itemNameToValues) {\n        let item = new InkListItem(this.name, key);\n        this._items.set(item.serialized(), value);\n      }\n    }\n\n    return this._items;\n  }\n\n  public ValueForItem(item: InkListItem) {\n    if (!item.itemName) return 0;\n\n    let intVal = this._itemNameToValues.get(item.itemName);\n    if (typeof intVal !== \"undefined\") return intVal;\n    else return 0;\n  }\n  public ContainsItem(item: InkListItem) {\n    if (!item.itemName) return false;\n    if (item.originName != this.name) return false;\n\n    return this._itemNameToValues.has(item.itemName);\n  }\n  public ContainsItemWithName(itemName: string) {\n    return this._itemNameToValues.has(itemName);\n  }\n  public TryGetItemWithValue(\n    val: number,\n    /* out */ item: InkListItem\n  ): TryGetResult<InkListItem> {\n    for (let [key, value] of this._itemNameToValues) {\n      if (value == val) {\n        item = new InkListItem(this.name, key);\n        return { result: item, exists: true };\n      }\n    }\n\n    item = InkListItem.Null;\n    return { result: item, exists: false };\n  }\n  public TryGetValueForItem(\n    item: InkListItem,\n    /* out */ intVal: number\n  ): TryGetResult<number> {\n    if (!item.itemName) return { result: 0, exists: false };\n    let value = this._itemNameToValues.get(item.itemName);\n\n    if (!value) return { result: 0, exists: false };\n    return { result: value, exists: true };\n  }\n}\n","import { InkListItem } from \"./InkList\";\nimport { ListValue } from \"./Value\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { TryGetResult } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\n\nexport class ListDefinitionsOrigin {\n  protected _lists: Map<string, ListDefinition>;\n  protected _allUnambiguousListValueCache: Map<string, ListValue>;\n\n  constructor(lists: ListDefinition[]) {\n    this._lists = new Map();\n    this._allUnambiguousListValueCache = new Map();\n\n    for (let list of lists) {\n      this._lists.set(list.name, list);\n\n      for (let [key, val] of list.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        let listValue = new ListValue(item, val);\n\n        if (!item.itemName) {\n          throw new Error(\"item.itemName is null or undefined.\");\n        }\n\n        this._allUnambiguousListValueCache.set(item.itemName, listValue);\n        this._allUnambiguousListValueCache.set(item.fullName, listValue);\n      }\n    }\n  }\n  get lists(): ListDefinition[] {\n    let listOfLists: ListDefinition[] = [];\n\n    for (let [, value] of this._lists) {\n      listOfLists.push(value);\n    }\n\n    return listOfLists;\n  }\n  public TryListGetDefinition(\n    name: string | null,\n    /* out */ def: ListDefinition | null\n  ): TryGetResult<ListDefinition | null> {\n    if (name === null) {\n      return { result: def, exists: false };\n    }\n    // initially, this function returns a boolean and the second parameter is an out.\n    let definition = this._lists.get(name);\n    if (!definition) return { result: def, exists: false };\n\n    return { result: definition, exists: true };\n  }\n  public FindSingleItemListWithName(name: string | null) {\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let val = this._allUnambiguousListValueCache.get(name);\n\n    if (typeof val !== \"undefined\") {\n      return val;\n    }\n\n    return null;\n  }\n}\n","import { Container } from \"./Container\";\nimport {\n  Value,\n  IntValue,\n  FloatValue,\n  StringValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n  BoolValue,\n} from \"./Value\";\nimport { Glue } from \"./Glue\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { Divert } from \"./Divert\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { VariableReference } from \"./VariableReference\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { Path } from \"./Path\";\nimport { Choice } from \"./Choice\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { InkListItem, InkList } from \"./InkList\";\nimport { InkObject } from \"./Object\";\nimport { asOrNull } from \"./TypeAssertion\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class JsonSerialisation {\n  public static JArrayToRuntimeObjList(\n    jArray: any[],\n    skipLast: boolean = false\n  ) {\n    let count = jArray.length;\n    if (skipLast) count--;\n\n    let list: InkObject[] = [];\n\n    for (let i = 0; i < count; i++) {\n      let jTok = jArray[i];\n      let runtimeObj = this.JTokenToRuntimeObject(jTok);\n      if (runtimeObj === null) {\n        return throwNullException(\"runtimeObj\");\n      }\n      list.push(runtimeObj);\n    }\n\n    return list;\n  }\n\n  public static WriteDictionaryRuntimeObjs(\n    writer: SimpleJson.Writer,\n    dictionary: Map<string, InkObject>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dictionary) {\n      writer.WritePropertyStart(key);\n      this.WriteRuntimeObject(writer, value);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteListRuntimeObjs(\n    writer: SimpleJson.Writer,\n    list: InkObject[]\n  ) {\n    writer.WriteArrayStart();\n    for (let value of list) {\n      this.WriteRuntimeObject(writer, value);\n    }\n    writer.WriteArrayEnd();\n  }\n\n  public static WriteIntDictionary(\n    writer: SimpleJson.Writer,\n    dict: Map<string, number>\n  ) {\n    writer.WriteObjectStart();\n    for (let [key, value] of dict) {\n      writer.WriteIntProperty(key, value);\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteRuntimeObject(\n    writer: SimpleJson.Writer,\n    obj: InkObject\n  ): void {\n    let container = asOrNull(obj, Container);\n    if (container) {\n      this.WriteRuntimeContainer(writer, container);\n      return;\n    }\n\n    let divert = asOrNull(obj, Divert);\n    if (divert) {\n      let divTypeKey = \"->\";\n      if (divert.isExternal) {\n        divTypeKey = \"x()\";\n      } else if (divert.pushesToStack) {\n        if (divert.stackPushType == PushPopType.Function) {\n          divTypeKey = \"f()\";\n        } else if (divert.stackPushType == PushPopType.Tunnel) {\n          divTypeKey = \"->t->\";\n        }\n      }\n\n      let targetStr;\n      if (divert.hasVariableTarget) {\n        targetStr = divert.variableDivertName;\n      } else {\n        targetStr = divert.targetPathString;\n      }\n\n      writer.WriteObjectStart();\n      writer.WriteProperty(divTypeKey, targetStr);\n\n      if (divert.hasVariableTarget) {\n        writer.WriteProperty(\"var\", true);\n      }\n\n      if (divert.isConditional) {\n        writer.WriteProperty(\"c\", true);\n      }\n\n      if (divert.externalArgs > 0) {\n        writer.WriteIntProperty(\"exArgs\", divert.externalArgs);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choicePoint = asOrNull(obj, ChoicePoint);\n    if (choicePoint) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"*\", choicePoint.pathStringOnChoice);\n      writer.WriteIntProperty(\"flg\", choicePoint.flags);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let boolVal = asOrNull(obj, BoolValue);\n    if (boolVal) {\n      writer.WriteBool(boolVal.value);\n      return;\n    }\n\n    let intVal = asOrNull(obj, IntValue);\n    if (intVal) {\n      writer.WriteInt(intVal.value);\n      return;\n    }\n\n    let floatVal = asOrNull(obj, FloatValue);\n    if (floatVal) {\n      writer.WriteFloat(floatVal.value);\n      return;\n    }\n\n    let strVal = asOrNull(obj, StringValue);\n    if (strVal) {\n      if (strVal.isNewline) {\n        writer.Write(\"\\n\", false);\n      } else {\n        writer.WriteStringStart();\n        writer.WriteStringInner(\"^\");\n        writer.WriteStringInner(strVal.value);\n        writer.WriteStringEnd();\n      }\n      return;\n    }\n\n    let listVal = asOrNull(obj, ListValue);\n    if (listVal) {\n      this.WriteInkList(writer, listVal);\n      return;\n    }\n\n    let divTargetVal = asOrNull(obj, DivertTargetValue);\n    if (divTargetVal) {\n      writer.WriteObjectStart();\n      if (divTargetVal.value === null) {\n        return throwNullException(\"divTargetVal.value\");\n      }\n      writer.WriteProperty(\"^->\", divTargetVal.value.componentsString);\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let varPtrVal = asOrNull(obj, VariablePointerValue);\n    if (varPtrVal) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"^var\", varPtrVal.value);\n      writer.WriteIntProperty(\"ci\", varPtrVal.contextIndex);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let glue = asOrNull(obj, Glue);\n    if (glue) {\n      writer.Write(\"<>\");\n      return;\n    }\n\n    let controlCmd = asOrNull(obj, ControlCommand);\n    if (controlCmd) {\n      writer.Write(\n        JsonSerialisation._controlCommandNames[controlCmd.commandType]\n      );\n      return;\n    }\n\n    let nativeFunc = asOrNull(obj, NativeFunctionCall);\n    if (nativeFunc) {\n      let name = nativeFunc.name;\n\n      if (name == \"^\") name = \"L^\";\n\n      writer.Write(name);\n      return;\n    }\n\n    let varRef = asOrNull(obj, VariableReference);\n    if (varRef) {\n      writer.WriteObjectStart();\n      let readCountPath = varRef.pathStringForCount;\n      if (readCountPath != null) {\n        writer.WriteProperty(\"CNT?\", readCountPath);\n      } else {\n        writer.WriteProperty(\"VAR?\", varRef.name);\n      }\n\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let varAss = asOrNull(obj, VariableAssignment);\n    if (varAss) {\n      writer.WriteObjectStart();\n\n      let key = varAss.isGlobal ? \"VAR=\" : \"temp=\";\n      writer.WriteProperty(key, varAss.variableName);\n\n      // Reassignment?\n      if (!varAss.isNewDeclaration) writer.WriteProperty(\"re\", true);\n\n      writer.WriteObjectEnd();\n\n      return;\n    }\n\n    let voidObj = asOrNull(obj, Void);\n    if (voidObj) {\n      writer.Write(\"void\");\n      return;\n    }\n\n    let tag = asOrNull(obj, Tag);\n    if (tag) {\n      writer.WriteObjectStart();\n      writer.WriteProperty(\"#\", tag.text);\n      writer.WriteObjectEnd();\n      return;\n    }\n\n    let choice = asOrNull(obj, Choice);\n    if (choice) {\n      this.WriteChoice(writer, choice);\n      return;\n    }\n\n    throw new Error(\"Failed to convert runtime object to Json token: \" + obj);\n  }\n\n  public static JObjectToDictionaryRuntimeObjs(jObject: Record<string, any>) {\n    let dict: Map<string, InkObject> = new Map();\n\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        let inkObject = this.JTokenToRuntimeObject(jObject[key]);\n        if (inkObject === null) {\n          return throwNullException(\"inkObject\");\n        }\n        dict.set(key, inkObject);\n      }\n    }\n\n    return dict;\n  }\n\n  public static JObjectToIntDictionary(jObject: Record<string, any>) {\n    let dict: Map<string, number> = new Map();\n    for (let key in jObject) {\n      if (jObject.hasOwnProperty(key)) {\n        dict.set(key, parseInt(jObject[key]));\n      }\n    }\n    return dict;\n  }\n\n  public static JTokenToRuntimeObject(token: any): InkObject | null {\n    if (\n      (typeof token === \"number\" && !isNaN(token)) ||\n      typeof token === \"boolean\"\n    ) {\n      return Value.Create(token);\n    }\n\n    if (typeof token === \"string\") {\n      let str = token.toString();\n\n      // String value\n      let firstChar = str[0];\n      if (firstChar == \"^\") return new StringValue(str.substring(1));\n      else if (firstChar == \"\\n\" && str.length == 1)\n        return new StringValue(\"\\n\");\n\n      // Glue\n      if (str == \"<>\") return new Glue();\n\n      // Control commands (would looking up in a hash set be faster?)\n      for (let i = 0; i < JsonSerialisation._controlCommandNames.length; ++i) {\n        let cmdName = JsonSerialisation._controlCommandNames[i];\n        if (str == cmdName) {\n          return new ControlCommand(i);\n        }\n      }\n\n      // Native functions\n      if (str == \"L^\") str = \"^\";\n      if (NativeFunctionCall.CallExistsWithName(str))\n        return NativeFunctionCall.CallWithName(str);\n\n      // Pop\n      if (str == \"->->\") return ControlCommand.PopTunnel();\n      else if (str == \"~ret\") return ControlCommand.PopFunction();\n\n      // Void\n      if (str == \"void\") return new Void();\n    }\n\n    if (typeof token === \"object\" && !Array.isArray(token)) {\n      let obj = token as Record<string, any>;\n      let propValue;\n\n      // Divert target value to path\n      if (obj[\"^->\"]) {\n        propValue = obj[\"^->\"];\n        return new DivertTargetValue(new Path(propValue.toString()));\n      }\n\n      // VariablePointerValue\n      if (obj[\"^var\"]) {\n        propValue = obj[\"^var\"];\n        let varPtr = new VariablePointerValue(propValue.toString());\n        if (\"ci\" in obj) {\n          propValue = obj[\"ci\"];\n          varPtr.contextIndex = parseInt(propValue);\n        }\n        return varPtr;\n      }\n\n      // Divert\n      let isDivert = false;\n      let pushesToStack = false;\n      let divPushType = PushPopType.Function;\n      let external = false;\n      if ((propValue = obj[\"->\"])) {\n        isDivert = true;\n      } else if ((propValue = obj[\"f()\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Function;\n      } else if ((propValue = obj[\"->t->\"])) {\n        isDivert = true;\n        pushesToStack = true;\n        divPushType = PushPopType.Tunnel;\n      } else if ((propValue = obj[\"x()\"])) {\n        isDivert = true;\n        external = true;\n        pushesToStack = false;\n        divPushType = PushPopType.Function;\n      }\n\n      if (isDivert) {\n        let divert = new Divert();\n        divert.pushesToStack = pushesToStack;\n        divert.stackPushType = divPushType;\n        divert.isExternal = external;\n\n        let target = propValue.toString();\n\n        if ((propValue = obj[\"var\"])) divert.variableDivertName = target;\n        else divert.targetPathString = target;\n\n        divert.isConditional = !!obj[\"c\"];\n\n        if (external) {\n          if ((propValue = obj[\"exArgs\"]))\n            divert.externalArgs = parseInt(propValue);\n        }\n\n        return divert;\n      }\n\n      // Choice\n      if ((propValue = obj[\"*\"])) {\n        let choice = new ChoicePoint();\n        choice.pathStringOnChoice = propValue.toString();\n\n        if ((propValue = obj[\"flg\"])) choice.flags = parseInt(propValue);\n\n        return choice;\n      }\n\n      // Variable reference\n      if ((propValue = obj[\"VAR?\"])) {\n        return new VariableReference(propValue.toString());\n      } else if ((propValue = obj[\"CNT?\"])) {\n        let readCountVarRef = new VariableReference();\n        readCountVarRef.pathStringForCount = propValue.toString();\n        return readCountVarRef;\n      }\n\n      // Variable assignment\n      let isVarAss = false;\n      let isGlobalVar = false;\n      if ((propValue = obj[\"VAR=\"])) {\n        isVarAss = true;\n        isGlobalVar = true;\n      } else if ((propValue = obj[\"temp=\"])) {\n        isVarAss = true;\n        isGlobalVar = false;\n      }\n      if (isVarAss) {\n        let varName = propValue.toString();\n        let isNewDecl = !obj[\"re\"];\n        let varAss = new VariableAssignment(varName, isNewDecl);\n        varAss.isGlobal = isGlobalVar;\n        return varAss;\n      }\n      if (obj[\"#\"] !== undefined) {\n        propValue = obj[\"#\"];\n        return new Tag(propValue.toString());\n      }\n\n      // List value\n      if ((propValue = obj[\"list\"])) {\n        // var listContent = (Dictionary<string, object>)propValue;\n        let listContent = propValue as Record<string, any>;\n        let rawList = new InkList();\n        if ((propValue = obj[\"origins\"])) {\n          // var namesAsObjs = (List<object>)propValue;\n          let namesAsObjs = propValue as string[];\n          // rawList.SetInitialOriginNames(namesAsObjs.Cast<string>().ToList());\n          rawList.SetInitialOriginNames(namesAsObjs);\n        }\n\n        for (let key in listContent) {\n          if (listContent.hasOwnProperty(key)) {\n            let nameToVal = listContent[key];\n            let item = new InkListItem(key);\n            let val = parseInt(nameToVal);\n            rawList.Add(item, val);\n          }\n        }\n\n        return new ListValue(rawList);\n      }\n\n      if (obj[\"originalChoicePath\"] != null) return this.JObjectToChoice(obj);\n    }\n\n    // Array is always a Runtime.Container\n    if (Array.isArray(token)) {\n      return this.JArrayToContainer(token);\n    }\n\n    if (token === null || token === undefined) return null;\n\n    throw new Error(\n      \"Failed to convert token to runtime object: \" +\n        this.toJson(token, [\"parent\"])\n    );\n  }\n\n  public static toJson<T>(\n    me: T,\n    removes?: (keyof T)[],\n    space?: number\n  ): string {\n    return JSON.stringify(\n      me,\n      (k, v) => (removes?.some((r) => r === k) ? undefined : v),\n      space\n    );\n  }\n\n  public static WriteRuntimeContainer(\n    writer: SimpleJson.Writer,\n    container: Container | null,\n    withoutName: boolean = false\n  ) {\n    writer.WriteArrayStart();\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    for (let c of container.content) this.WriteRuntimeObject(writer, c);\n\n    let namedOnlyContent = container.namedOnlyContent;\n    let countFlags = container.countFlags;\n    let hasNameProperty = container.name != null && !withoutName;\n\n    let hasTerminator =\n      namedOnlyContent != null || countFlags > 0 || hasNameProperty;\n    if (hasTerminator) {\n      writer.WriteObjectStart();\n    }\n\n    if (namedOnlyContent != null) {\n      for (let [key, value] of namedOnlyContent) {\n        let name = key;\n        let namedContainer = asOrNull(value, Container);\n        writer.WritePropertyStart(name);\n        this.WriteRuntimeContainer(writer, namedContainer, true);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (countFlags > 0) writer.WriteIntProperty(\"#f\", countFlags);\n\n    if (hasNameProperty) writer.WriteProperty(\"#n\", container.name);\n\n    if (hasTerminator) writer.WriteObjectEnd();\n    else writer.WriteNull();\n\n    writer.WriteArrayEnd();\n  }\n\n  public static JArrayToContainer(jArray: any[]) {\n    let container = new Container();\n    container.content = this.JArrayToRuntimeObjList(jArray, true);\n\n    let terminatingObj = jArray[jArray.length - 1] as Record<string, any>;\n    if (terminatingObj != null) {\n      let namedOnlyContent = new Map();\n\n      for (let key in terminatingObj) {\n        if (key == \"#f\") {\n          container.countFlags = parseInt(terminatingObj[key]);\n        } else if (key == \"#n\") {\n          container.name = terminatingObj[key].toString();\n        } else {\n          let namedContentItem = this.JTokenToRuntimeObject(\n            terminatingObj[key]\n          );\n          // var namedSubContainer = namedContentItem as Container;\n          let namedSubContainer = asOrNull(namedContentItem, Container);\n          if (namedSubContainer) namedSubContainer.name = key;\n          namedOnlyContent.set(key, namedContentItem);\n        }\n      }\n\n      container.namedOnlyContent = namedOnlyContent;\n    }\n\n    return container;\n  }\n\n  public static JObjectToChoice(jObj: Record<string, any>) {\n    let choice = new Choice();\n    choice.text = jObj[\"text\"].toString();\n    choice.index = parseInt(jObj[\"index\"]);\n    choice.sourcePath = jObj[\"originalChoicePath\"].toString();\n    choice.originalThreadIndex = parseInt(jObj[\"originalThreadIndex\"]);\n    choice.pathStringOnChoice = jObj[\"targetPath\"].toString();\n    return choice;\n  }\n\n  public static WriteChoice(writer: SimpleJson.Writer, choice: Choice) {\n    writer.WriteObjectStart();\n    writer.WriteProperty(\"text\", choice.text);\n    writer.WriteIntProperty(\"index\", choice.index);\n    writer.WriteProperty(\"originalChoicePath\", choice.sourcePath);\n    writer.WriteIntProperty(\"originalThreadIndex\", choice.originalThreadIndex);\n    writer.WriteProperty(\"targetPath\", choice.pathStringOnChoice);\n    writer.WriteObjectEnd();\n  }\n\n  public static WriteInkList(writer: SimpleJson.Writer, listVal: ListValue) {\n    let rawList = listVal.value;\n    if (rawList === null) {\n      return throwNullException(\"rawList\");\n    }\n\n    writer.WriteObjectStart();\n    writer.WritePropertyStart(\"list\");\n    writer.WriteObjectStart();\n\n    for (let [key, val] of rawList) {\n      let item = InkListItem.fromSerializedKey(key);\n      let itemVal = val;\n\n      if (item.itemName === null) {\n        return throwNullException(\"item.itemName\");\n      }\n\n      writer.WritePropertyNameStart();\n      writer.WritePropertyNameInner(item.originName ? item.originName : \"?\");\n      writer.WritePropertyNameInner(\".\");\n      writer.WritePropertyNameInner(item.itemName);\n      writer.WritePropertyNameEnd();\n\n      writer.Write(itemVal);\n\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    writer.WritePropertyEnd();\n\n    if (\n      rawList.Count == 0 &&\n      rawList.originNames != null &&\n      rawList.originNames.length > 0\n    ) {\n      writer.WritePropertyStart(\"origins\");\n      writer.WriteArrayStart();\n      for (let name of rawList.originNames) writer.Write(name);\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n  }\n\n  public static ListDefinitionsToJToken(origin: ListDefinitionsOrigin) {\n    let result: Record<string, any> = {};\n\n    for (let def of origin.lists) {\n      let listDefJson: Record<string, any> = {};\n\n      for (let [key, val] of def.items) {\n        let item = InkListItem.fromSerializedKey(key);\n        if (item.itemName === null) {\n          return throwNullException(\"item.itemName\");\n        }\n        listDefJson[item.itemName] = val;\n      }\n\n      result[def.name] = listDefJson;\n    }\n\n    return result;\n  }\n\n  public static JTokenToListDefinitions(obj: Record<string, any>) {\n    // var defsObj = (Dictionary<string, object>)obj;\n    let defsObj = obj;\n\n    let allDefs: ListDefinition[] = [];\n\n    for (let key in defsObj) {\n      if (defsObj.hasOwnProperty(key)) {\n        let name = key.toString();\n        // var listDefJson = (Dictionary<string, object>)kv.Value;\n        let listDefJson = defsObj[key] as Record<string, any>;\n\n        // Cast (string, object) to (string, int) for items\n        let items: Map<string, number> = new Map();\n\n        for (let nameValueKey in listDefJson) {\n          if (defsObj.hasOwnProperty(key)) {\n            let nameValue = listDefJson[nameValueKey];\n            items.set(nameValueKey, parseInt(nameValue));\n          }\n        }\n\n        let def = new ListDefinition(name, items);\n        allDefs.push(def);\n      }\n    }\n\n    return new ListDefinitionsOrigin(allDefs);\n  }\n\n  private static _controlCommandNames = (() => {\n    let _controlCommandNames: string[] = [];\n\n    _controlCommandNames[ControlCommand.CommandType.EvalStart] = \"ev\";\n    _controlCommandNames[ControlCommand.CommandType.EvalOutput] = \"out\";\n    _controlCommandNames[ControlCommand.CommandType.EvalEnd] = \"/ev\";\n    _controlCommandNames[ControlCommand.CommandType.Duplicate] = \"du\";\n    _controlCommandNames[ControlCommand.CommandType.PopEvaluatedValue] = \"pop\";\n    _controlCommandNames[ControlCommand.CommandType.PopFunction] = \"~ret\";\n    _controlCommandNames[ControlCommand.CommandType.PopTunnel] = \"->->\";\n    _controlCommandNames[ControlCommand.CommandType.BeginString] = \"str\";\n    _controlCommandNames[ControlCommand.CommandType.EndString] = \"/str\";\n    _controlCommandNames[ControlCommand.CommandType.NoOp] = \"nop\";\n    _controlCommandNames[ControlCommand.CommandType.ChoiceCount] = \"choiceCnt\";\n    _controlCommandNames[ControlCommand.CommandType.Turns] = \"turn\";\n    _controlCommandNames[ControlCommand.CommandType.TurnsSince] = \"turns\";\n    _controlCommandNames[ControlCommand.CommandType.ReadCount] = \"readc\";\n    _controlCommandNames[ControlCommand.CommandType.Random] = \"rnd\";\n    _controlCommandNames[ControlCommand.CommandType.SeedRandom] = \"srnd\";\n    _controlCommandNames[ControlCommand.CommandType.VisitIndex] = \"visit\";\n    _controlCommandNames[ControlCommand.CommandType.SequenceShuffleIndex] =\n      \"seq\";\n    _controlCommandNames[ControlCommand.CommandType.StartThread] = \"thread\";\n    _controlCommandNames[ControlCommand.CommandType.Done] = \"done\";\n    _controlCommandNames[ControlCommand.CommandType.End] = \"end\";\n    _controlCommandNames[ControlCommand.CommandType.ListFromInt] = \"listInt\";\n    _controlCommandNames[ControlCommand.CommandType.ListRange] = \"range\";\n    _controlCommandNames[ControlCommand.CommandType.ListRandom] = \"lrnd\";\n    _controlCommandNames[ControlCommand.CommandType.BeginTag] = \"#\";\n    _controlCommandNames[ControlCommand.CommandType.EndTag] = \"/#\";\n\n    for (let i = 0; i < ControlCommand.CommandType.TOTAL_VALUES; ++i) {\n      if (_controlCommandNames[i] == null)\n        throw new Error(\"Control command not accounted for in serialisation\");\n    }\n\n    return _controlCommandNames;\n  })();\n}\n","import { PushPopType } from \"./PushPop\";\nimport { Path } from \"./Path\";\nimport { Story } from \"./Story\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { ListValue } from \"./Value\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { Pointer } from \"./Pointer\";\nimport { InkObject } from \"./Object\";\nimport { Debug } from \"./Debug\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\n\nexport class CallStack {\n  get elements() {\n    return this.callStack;\n  }\n\n  get depth() {\n    return this.elements.length;\n  }\n\n  get currentElement() {\n    let thread = this._threads[this._threads.length - 1];\n    let cs = thread.callstack;\n    return cs[cs.length - 1];\n  }\n\n  get currentElementIndex() {\n    return this.callStack.length - 1;\n  }\n\n  get currentThread(): CallStack.Thread {\n    return this._threads[this._threads.length - 1];\n  }\n  set currentThread(value: CallStack.Thread) {\n    Debug.Assert(\n      this._threads.length == 1,\n      \"Shouldn't be directly setting the current thread when we have a stack of them\"\n    );\n\n    this._threads.length = 0;\n    this._threads.push(value);\n  }\n\n  get canPop() {\n    return this.callStack.length > 1;\n  }\n\n  constructor(storyContext: Story);\n  constructor(toCopy: CallStack);\n  constructor() {\n    if (arguments[0] instanceof Story) {\n      let storyContext = arguments[0] as Story;\n\n      this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n      this.Reset();\n    } else {\n      let toCopy = arguments[0] as CallStack;\n\n      this._threads = [];\n      for (let otherThread of toCopy._threads) {\n        this._threads.push(otherThread.Copy());\n      }\n      this._threadCounter = toCopy._threadCounter;\n      this._startOfRoot = toCopy._startOfRoot.copy();\n    }\n  }\n\n  public Reset() {\n    this._threads = [];\n    this._threads.push(new CallStack.Thread());\n\n    this._threads[0].callstack.push(\n      new CallStack.Element(PushPopType.Tunnel, this._startOfRoot)\n    );\n  }\n\n  public SetJsonToken(jObject: Record<string, any>, storyContext: Story) {\n    this._threads.length = 0;\n\n    // TODO: (List<object>) jObject [\"threads\"];\n    let jThreads: any[] = jObject[\"threads\"];\n\n    for (let jThreadTok of jThreads) {\n      // TODO: var jThreadObj = (Dictionary<string, object>)jThreadTok;\n      let jThreadObj = jThreadTok;\n      let thread = new CallStack.Thread(jThreadObj, storyContext);\n      this._threads.push(thread);\n    }\n\n    // TODO: (int)jObject [\"threadCounter\"];\n    this._threadCounter = parseInt(jObject[\"threadCounter\"]);\n    this._startOfRoot = Pointer.StartOf(storyContext.rootContentContainer);\n  }\n  public WriteJson(w: SimpleJson.Writer) {\n    w.WriteObject((writer) => {\n      writer.WritePropertyStart(\"threads\");\n      writer.WriteArrayStart();\n\n      for (let thread of this._threads) {\n        thread.WriteJson(writer);\n      }\n\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WritePropertyStart(\"threadCounter\");\n      writer.WriteInt(this._threadCounter);\n      writer.WritePropertyEnd();\n    });\n  }\n\n  public PushThread() {\n    let newThread = this.currentThread.Copy();\n    this._threadCounter++;\n    newThread.threadIndex = this._threadCounter;\n    this._threads.push(newThread);\n  }\n\n  public ForkThread() {\n    let forkedThread = this.currentThread.Copy();\n    this._threadCounter++;\n    forkedThread.threadIndex = this._threadCounter;\n    return forkedThread;\n  }\n\n  public PopThread() {\n    if (this.canPopThread) {\n      this._threads.splice(this._threads.indexOf(this.currentThread), 1); // should be equivalent to a pop()\n    } else {\n      throw new Error(\"Can't pop thread\");\n    }\n  }\n\n  get canPopThread() {\n    return this._threads.length > 1 && !this.elementIsEvaluateFromGame;\n  }\n\n  get elementIsEvaluateFromGame() {\n    return this.currentElement.type == PushPopType.FunctionEvaluationFromGame;\n  }\n\n  public Push(\n    type: PushPopType,\n    externalEvaluationStackHeight: number = 0,\n    outputStreamLengthWithPushed: number = 0\n  ) {\n    let element = new CallStack.Element(\n      type,\n      this.currentElement.currentPointer,\n      false\n    );\n\n    element.evaluationStackHeightWhenPushed = externalEvaluationStackHeight;\n    element.functionStartInOutputStream = outputStreamLengthWithPushed;\n\n    this.callStack.push(element);\n  }\n\n  public CanPop(type: PushPopType | null = null) {\n    if (!this.canPop) return false;\n\n    if (type == null) return true;\n\n    return this.currentElement.type == type;\n  }\n\n  public Pop(type: PushPopType | null = null) {\n    if (this.CanPop(type)) {\n      this.callStack.pop();\n      return;\n    } else {\n      throw new Error(\"Mismatched push/pop in Callstack\");\n    }\n  }\n\n  public GetTemporaryVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    let varValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (varValue.exists) {\n      return varValue.result;\n    } else {\n      return null;\n    }\n  }\n\n  public SetTemporaryVariable(\n    name: string,\n    value: any,\n    declareNew: boolean,\n    contextIndex: number = -1\n  ) {\n    if (contextIndex == -1) contextIndex = this.currentElementIndex + 1;\n\n    let contextElement = this.callStack[contextIndex - 1];\n\n    if (!declareNew && !contextElement.temporaryVariables.get(name)) {\n      throw new Error(\"Could not find temporary variable to set: \" + name);\n    }\n\n    let oldValue = tryGetValueFromMap(\n      contextElement.temporaryVariables,\n      name,\n      null\n    );\n    if (oldValue.exists)\n      ListValue.RetainListOriginsForAssignment(oldValue.result, value);\n\n    contextElement.temporaryVariables.set(name, value);\n  }\n\n  public ContextForVariableNamed(name: string) {\n    if (this.currentElement.temporaryVariables.get(name)) {\n      return this.currentElementIndex + 1;\n    } else {\n      return 0;\n    }\n  }\n\n  public ThreadWithIndex(index: number) {\n    let filtered = this._threads.filter((t) => {\n      if (t.threadIndex == index) return t;\n    });\n\n    return filtered.length > 0 ? filtered[0] : null;\n  }\n\n  get callStack() {\n    return this.currentThread.callstack;\n  }\n\n  get callStackTrace() {\n    let sb = new StringBuilder();\n\n    for (let t = 0; t < this._threads.length; t++) {\n      let thread = this._threads[t];\n      let isCurrent = t == this._threads.length - 1;\n      sb.AppendFormat(\n        \"=== THREAD {0}/{1} {2}===\\n\",\n        t + 1,\n        this._threads.length,\n        isCurrent ? \"(current) \" : \"\"\n      );\n\n      for (let i = 0; i < thread.callstack.length; i++) {\n        if (thread.callstack[i].type == PushPopType.Function)\n          sb.Append(\"  [FUNCTION] \");\n        else sb.Append(\"  [TUNNEL] \");\n\n        let pointer = thread.callstack[i].currentPointer;\n        if (!pointer.isNull) {\n          sb.Append(\"<SOMEWHERE IN \");\n          if (pointer.container === null) {\n            return throwNullException(\"pointer.container\");\n          }\n          sb.Append(pointer.container.path.toString());\n          sb.AppendLine(\">\");\n        }\n      }\n    }\n\n    return sb.toString();\n  }\n\n  public _threads!: CallStack.Thread[]; // Banged because it's initialized in Reset().\n  public _threadCounter: number = 0;\n  public _startOfRoot: Pointer = Pointer.Null;\n}\n\nexport namespace CallStack {\n  export class Element {\n    public currentPointer: Pointer;\n    public inExpressionEvaluation: boolean;\n    public temporaryVariables: Map<string, InkObject>;\n    public type: PushPopType;\n\n    public evaluationStackHeightWhenPushed: number = 0;\n    public functionStartInOutputStream: number = 0;\n\n    constructor(\n      type: PushPopType,\n      pointer: Pointer,\n      inExpressionEvaluation: boolean = false\n    ) {\n      this.currentPointer = pointer.copy();\n      this.inExpressionEvaluation = inExpressionEvaluation;\n      this.temporaryVariables = new Map();\n      this.type = type;\n    }\n\n    public Copy() {\n      let copy = new Element(\n        this.type,\n        this.currentPointer,\n        this.inExpressionEvaluation\n      );\n      copy.temporaryVariables = new Map(this.temporaryVariables);\n      copy.evaluationStackHeightWhenPushed =\n        this.evaluationStackHeightWhenPushed;\n      copy.functionStartInOutputStream = this.functionStartInOutputStream;\n      return copy;\n    }\n  }\n\n  export class Thread {\n    public callstack: Element[];\n    public threadIndex: number = 0;\n    public previousPointer: Pointer = Pointer.Null;\n\n    constructor();\n    constructor(jThreadObj: any, storyContext: Story);\n    constructor() {\n      this.callstack = [];\n\n      if (arguments[0] && arguments[1]) {\n        let jThreadObj = arguments[0];\n        let storyContext = arguments[1];\n\n        // TODO: (int) jThreadObj['threadIndex'] can raise;\n        this.threadIndex = parseInt(jThreadObj[\"threadIndex\"]);\n\n        let jThreadCallstack = jThreadObj[\"callstack\"];\n\n        for (let jElTok of jThreadCallstack) {\n          let jElementObj = jElTok;\n\n          // TODO: (int) jElementObj['type'] can raise;\n          let pushPopType: PushPopType = parseInt(jElementObj[\"type\"]);\n\n          let pointer = Pointer.Null;\n\n          let currentContainerPathStr: string;\n          // TODO: jElementObj.TryGetValue (\"cPath\", out currentContainerPathStrToken);\n          let currentContainerPathStrToken = jElementObj[\"cPath\"];\n          if (typeof currentContainerPathStrToken !== \"undefined\") {\n            currentContainerPathStr = currentContainerPathStrToken.toString();\n\n            let threadPointerResult = storyContext.ContentAtPath(\n              new Path(currentContainerPathStr)\n            );\n            pointer.container = threadPointerResult.container;\n            pointer.index = parseInt(jElementObj[\"idx\"]);\n\n            if (threadPointerResult.obj == null)\n              throw new Error(\n                \"When loading state, internal story location couldn't be found: \" +\n                  currentContainerPathStr +\n                  \". Has the story changed since this save data was created?\"\n              );\n            else if (threadPointerResult.approximate) {\n              if (pointer.container === null) {\n                return throwNullException(\"pointer.container\");\n              }\n              storyContext.Warning(\n                \"When loading state, exact internal story location couldn't be found: '\" +\n                  currentContainerPathStr +\n                  \"', so it was approximated to '\" +\n                  pointer.container.path.toString() +\n                  \"' to recover. Has the story changed since this save data was created?\"\n              );\n            }\n          }\n\n          let inExpressionEvaluation = !!jElementObj[\"exp\"];\n\n          let el = new Element(pushPopType, pointer, inExpressionEvaluation);\n\n          let temps = jElementObj[\"temp\"];\n          if (typeof temps !== \"undefined\") {\n            el.temporaryVariables =\n              JsonSerialisation.JObjectToDictionaryRuntimeObjs(temps);\n          } else {\n            el.temporaryVariables.clear();\n          }\n\n          this.callstack.push(el);\n        }\n\n        let prevContentObjPath = jThreadObj[\"previousContentObject\"];\n        if (typeof prevContentObjPath !== \"undefined\") {\n          let prevPath = new Path(prevContentObjPath.toString());\n          this.previousPointer = storyContext.PointerAtPath(prevPath);\n        }\n      }\n    }\n\n    public Copy() {\n      let copy = new Thread();\n      copy.threadIndex = this.threadIndex;\n      for (let e of this.callstack) {\n        copy.callstack.push(e.Copy());\n      }\n      copy.previousPointer = this.previousPointer.copy();\n      return copy;\n    }\n\n    public WriteJson(writer: SimpleJson.Writer) {\n      writer.WriteObjectStart();\n\n      writer.WritePropertyStart(\"callstack\");\n      writer.WriteArrayStart();\n      for (let el of this.callstack) {\n        writer.WriteObjectStart();\n        if (!el.currentPointer.isNull) {\n          if (el.currentPointer.container === null) {\n            return throwNullException(\"el.currentPointer.container\");\n          }\n          writer.WriteProperty(\n            \"cPath\",\n            el.currentPointer.container.path.componentsString\n          );\n          writer.WriteIntProperty(\"idx\", el.currentPointer.index);\n        }\n\n        writer.WriteProperty(\"exp\", el.inExpressionEvaluation);\n        writer.WriteIntProperty(\"type\", el.type);\n\n        if (el.temporaryVariables.size > 0) {\n          writer.WritePropertyStart(\"temp\");\n          JsonSerialisation.WriteDictionaryRuntimeObjs(\n            writer,\n            el.temporaryVariables\n          );\n          writer.WritePropertyEnd();\n        }\n\n        writer.WriteObjectEnd();\n      }\n      writer.WriteArrayEnd();\n      writer.WritePropertyEnd();\n\n      writer.WriteIntProperty(\"threadIndex\", this.threadIndex);\n\n      if (!this.previousPointer.isNull) {\n        let resolvedPointer = this.previousPointer.Resolve();\n        if (resolvedPointer === null) {\n          return throwNullException(\"this.previousPointer.Resolve()\");\n        }\n        writer.WriteProperty(\n          \"previousContentObject\",\n          resolvedPointer.path.toString()\n        );\n      }\n\n      writer.WriteObjectEnd();\n    }\n  }\n}\n","import {\n  AbstractValue,\n  Value,\n  VariablePointerValue,\n  ListValue,\n  IntValue,\n  FloatValue,\n  BoolValue,\n} from \"./Value\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { InkObject } from \"./Object\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { StoryException } from \"./StoryException\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { asOrThrows, asOrNull, isEquatable } from \"./TypeAssertion\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { throwNullException } from \"./NullException\";\nimport { CallStack } from \"./CallStack\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { InkList } from \"./Story\";\nimport { Path } from \"./Path\";\n\n// Fake class wrapper around VariableState to have correct typing\n// when using the Proxy syntax in typescript\nfunction VariablesStateAccessor<T>(): new () => Pick<T, keyof T> {\n  return class {} as any;\n}\n\ntype VariableStateValue = boolean | string | number | InkList | Path | null;\n\nexport class VariablesState extends VariablesStateAccessor<\n  Record<string, any>\n>() {\n  // The way variableChangedEvent is a bit different than the reference implementation.\n  // Originally it uses the C# += operator to add delegates, but in js we need to maintain\n  // an actual collection of delegates (ie. callbacks) to register a new one, there is a\n  // special ObserveVariableChange method below.\n  public variableChangedEventCallbacks: Array<\n    (variableName: string, newValue: InkObject) => void\n  > = [];\n  public variableChangedEvent(variableName: string, newValue: InkObject): void {\n    for (let callback of this.variableChangedEventCallbacks) {\n      callback(variableName, newValue);\n    }\n  }\n\n  public patch: StatePatch | null = null;\n\n  get batchObservingVariableChanges() {\n    return this._batchObservingVariableChanges;\n  }\n  set batchObservingVariableChanges(value: boolean) {\n    this._batchObservingVariableChanges = value;\n    if (value) {\n      this._changedVariablesForBatchObs = new Set();\n    } else {\n      if (this._changedVariablesForBatchObs != null) {\n        for (let variableName of this._changedVariablesForBatchObs) {\n          let currentValue = this._globalVariables.get(variableName);\n          if (!currentValue) {\n            throwNullException(\"currentValue\");\n          } else {\n            this.variableChangedEvent(variableName, currentValue);\n          }\n        }\n\n        this._changedVariablesForBatchObs = null;\n      }\n    }\n  }\n\n  get callStack() {\n    return this._callStack;\n  }\n  set callStack(callStack) {\n    this._callStack = callStack;\n  }\n\n  private _batchObservingVariableChanges: boolean = false;\n\n  // the original code uses a magic getter and setter for global variables,\n  // allowing things like variableState['varname]. This is not quite possible\n  // in js without a Proxy, so it is replaced with this $ function.\n  public $(variableName: string): VariableStateValue;\n  public $(variableName: string, value: VariableStateValue): void;\n  public $(variableName: string, value?: any) {\n    if (typeof value === \"undefined\") {\n      let varContents = null;\n\n      if (this.patch !== null) {\n        varContents = this.patch.TryGetGlobal(variableName, null);\n        if (varContents.exists)\n          return (varContents.result as AbstractValue).valueObject;\n      }\n\n      varContents = this._globalVariables.get(variableName);\n\n      if (typeof varContents === \"undefined\") {\n        varContents = this._defaultGlobalVariables.get(variableName);\n      }\n\n      if (typeof varContents !== \"undefined\")\n        return (varContents as AbstractValue).valueObject;\n      else return null;\n    } else {\n      if (typeof this._defaultGlobalVariables.get(variableName) === \"undefined\")\n        throw new StoryException(\n          \"Cannot assign to a variable (\" +\n            variableName +\n            \") that hasn't been declared in the story\"\n        );\n\n      let val = Value.Create(value);\n      if (val == null) {\n        if (value == null) {\n          throw new Error(\"Cannot pass null to VariableState\");\n        } else {\n          throw new Error(\n            \"Invalid value passed to VariableState: \" + value.toString()\n          );\n        }\n      }\n\n      this.SetGlobal(variableName, val);\n    }\n  }\n\n  constructor(\n    callStack: CallStack,\n    listDefsOrigin: ListDefinitionsOrigin | null\n  ) {\n    super();\n    this._globalVariables = new Map();\n    this._callStack = callStack;\n    this._listDefsOrigin = listDefsOrigin;\n\n    // if es6 proxies are available, use them.\n    try {\n      // the proxy is used to allow direct manipulation of global variables.\n      // It first tries to access the objects own property, and if none is\n      // found it delegates the call to the $ method, defined below\n      let p = new Proxy(this, {\n        get(target: any, name) {\n          return name in target ? target[name] : target.$(name);\n        },\n        set(target: any, name, value) {\n          if (name in target) target[name] = value;\n          else target.$(name, value);\n          return true; // returning a falsy value make the trap fail\n        },\n      });\n\n      return p;\n    } catch (e) {\n      // the proxy object is not available in this context. we should warn the\n      // dev but writing to the console feels a bit intrusive.\n      // console.log(\"ES6 Proxy not available - direct manipulation of global variables can't work, use $() instead.\");\n    }\n  }\n\n  public ApplyPatch() {\n    if (this.patch === null) {\n      return throwNullException(\"this.patch\");\n    }\n\n    for (let [namedVarKey, namedVarValue] of this.patch.globals) {\n      this._globalVariables.set(namedVarKey, namedVarValue);\n    }\n\n    if (this._changedVariablesForBatchObs !== null) {\n      for (let name of this.patch.changedVariables) {\n        this._changedVariablesForBatchObs.add(name);\n      }\n    }\n\n    this.patch = null;\n  }\n\n  public SetJsonToken(jToken: Record<string, any>) {\n    this._globalVariables.clear();\n\n    for (let [varValKey, varValValue] of this._defaultGlobalVariables) {\n      let loadedToken = jToken[varValKey];\n      if (typeof loadedToken !== \"undefined\") {\n        let tokenInkObject =\n          JsonSerialisation.JTokenToRuntimeObject(loadedToken);\n        if (tokenInkObject === null) {\n          return throwNullException(\"tokenInkObject\");\n        }\n        this._globalVariables.set(varValKey, tokenInkObject);\n      } else {\n        this._globalVariables.set(varValKey, varValValue);\n      }\n    }\n  }\n\n  public static dontSaveDefaultValues: boolean = true;\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n    for (let [keyValKey, keyValValue] of this._globalVariables) {\n      let name = keyValKey;\n      let val = keyValValue;\n\n      if (VariablesState.dontSaveDefaultValues) {\n        if (this._defaultGlobalVariables.has(name)) {\n          let defaultVal = this._defaultGlobalVariables.get(name)!;\n          if (this.RuntimeObjectsEqual(val, defaultVal)) continue;\n        }\n      }\n\n      writer.WritePropertyStart(name);\n      JsonSerialisation.WriteRuntimeObject(writer, val);\n      writer.WritePropertyEnd();\n    }\n    writer.WriteObjectEnd();\n  }\n\n  public RuntimeObjectsEqual(\n    obj1: InkObject | null,\n    obj2: InkObject | null\n  ): boolean {\n    if (obj1 === null) {\n      return throwNullException(\"obj1\");\n    }\n    if (obj2 === null) {\n      return throwNullException(\"obj2\");\n    }\n\n    if (obj1.constructor !== obj2.constructor) return false;\n\n    let boolVal = asOrNull(obj1, BoolValue);\n    if (boolVal !== null) {\n      return boolVal.value === asOrThrows(obj2, BoolValue).value;\n    }\n\n    let intVal = asOrNull(obj1, IntValue);\n    if (intVal !== null) {\n      return intVal.value === asOrThrows(obj2, IntValue).value;\n    }\n\n    let floatVal = asOrNull(obj1, FloatValue);\n    if (floatVal !== null) {\n      return floatVal.value === asOrThrows(obj2, FloatValue).value;\n    }\n\n    let val1 = asOrNull(obj1, Value);\n    let val2 = asOrNull(obj2, Value);\n    if (val1 !== null && val2 !== null) {\n      if (isEquatable(val1.valueObject) && isEquatable(val2.valueObject)) {\n        return val1.valueObject.Equals(val2.valueObject);\n      } else {\n        return val1.valueObject === val2.valueObject;\n      }\n    }\n\n    throw new Error(\n      \"FastRoughDefinitelyEquals: Unsupported runtime object type: \" +\n        obj1.constructor.name\n    );\n  }\n\n  public GetVariableWithName(\n    name: string | null,\n    contextIndex: number = -1\n  ): InkObject | null {\n    let varValue = this.GetRawVariableWithName(name, contextIndex);\n\n    // var varPointer = varValue as VariablePointerValue;\n    let varPointer = asOrNull(varValue, VariablePointerValue);\n    if (varPointer !== null) {\n      varValue = this.ValueAtVariablePointer(varPointer);\n    }\n\n    return varValue;\n  }\n\n  public TryGetDefaultVariableValue(name: string | null): InkObject | null {\n    let val = tryGetValueFromMap(this._defaultGlobalVariables, name, null);\n    return val.exists ? val.result : null;\n  }\n\n  public GlobalVariableExistsWithName(name: string) {\n    return (\n      this._globalVariables.has(name) ||\n      (this._defaultGlobalVariables !== null &&\n        this._defaultGlobalVariables.has(name))\n    );\n  }\n\n  public GetRawVariableWithName(name: string | null, contextIndex: number) {\n    let varValue: InkObject | null = null;\n\n    if (contextIndex == 0 || contextIndex == -1) {\n      let variableValue = null;\n      if (this.patch !== null) {\n        variableValue = this.patch.TryGetGlobal(name, null);\n        if (variableValue.exists) return variableValue.result!;\n      }\n\n      // this is a conditional assignment\n      variableValue = tryGetValueFromMap(this._globalVariables, name, null);\n      if (variableValue.exists) return variableValue.result;\n\n      if (this._defaultGlobalVariables !== null) {\n        variableValue = tryGetValueFromMap(\n          this._defaultGlobalVariables,\n          name,\n          null\n        );\n        if (variableValue.exists) return variableValue.result;\n      }\n\n      if (this._listDefsOrigin === null)\n        return throwNullException(\"VariablesState._listDefsOrigin\");\n      let listItemValue = this._listDefsOrigin.FindSingleItemListWithName(name);\n      if (listItemValue) return listItemValue;\n    }\n\n    varValue = this._callStack.GetTemporaryVariableWithName(name, contextIndex);\n\n    return varValue;\n  }\n\n  public ValueAtVariablePointer(pointer: VariablePointerValue) {\n    return this.GetVariableWithName(pointer.variableName, pointer.contextIndex);\n  }\n\n  public Assign(varAss: VariableAssignment, value: InkObject) {\n    let name = varAss.variableName;\n    if (name === null) {\n      return throwNullException(\"name\");\n    }\n    let contextIndex = -1;\n\n    let setGlobal = false;\n    if (varAss.isNewDeclaration) {\n      setGlobal = varAss.isGlobal;\n    } else {\n      setGlobal = this.GlobalVariableExistsWithName(name);\n    }\n\n    if (varAss.isNewDeclaration) {\n      // var varPointer = value as VariablePointerValue;\n      let varPointer = asOrNull(value, VariablePointerValue);\n      if (varPointer !== null) {\n        let fullyResolvedVariablePointer =\n          this.ResolveVariablePointer(varPointer);\n        value = fullyResolvedVariablePointer;\n      }\n    } else {\n      let existingPointer = null;\n      do {\n        // existingPointer = GetRawVariableWithName (name, contextIndex) as VariablePointerValue;\n        existingPointer = asOrNull(\n          this.GetRawVariableWithName(name, contextIndex),\n          VariablePointerValue\n        );\n        if (existingPointer != null) {\n          name = existingPointer.variableName;\n          contextIndex = existingPointer.contextIndex;\n          setGlobal = contextIndex == 0;\n        }\n      } while (existingPointer != null);\n    }\n\n    if (setGlobal) {\n      this.SetGlobal(name, value);\n    } else {\n      this._callStack.SetTemporaryVariable(\n        name,\n        value,\n        varAss.isNewDeclaration,\n        contextIndex\n      );\n    }\n  }\n\n  public SnapshotDefaultGlobals() {\n    this._defaultGlobalVariables = new Map(this._globalVariables);\n  }\n\n  public RetainListOriginsForAssignment(\n    oldValue: InkObject,\n    newValue: InkObject\n  ) {\n    let oldList = asOrThrows(oldValue, ListValue);\n    let newList = asOrThrows(newValue, ListValue);\n\n    if (oldList.value && newList.value && newList.value.Count == 0) {\n      newList.value.SetInitialOriginNames(oldList.value.originNames);\n    }\n  }\n\n  public SetGlobal(variableName: string | null, value: InkObject) {\n    let oldValue = null;\n\n    if (this.patch === null) {\n      oldValue = tryGetValueFromMap(this._globalVariables, variableName, null);\n    }\n\n    if (this.patch !== null) {\n      oldValue = this.patch.TryGetGlobal(variableName, null);\n      if (!oldValue.exists) {\n        oldValue = tryGetValueFromMap(\n          this._globalVariables,\n          variableName,\n          null\n        );\n      }\n    }\n\n    ListValue.RetainListOriginsForAssignment(oldValue!.result!, value);\n\n    if (variableName === null) {\n      return throwNullException(\"variableName\");\n    }\n\n    if (this.patch !== null) {\n      this.patch.SetGlobal(variableName, value);\n    } else {\n      this._globalVariables.set(variableName, value);\n    }\n\n    // TODO: Not sure !== is equivalent to !value.Equals(oldValue)\n    if (\n      this.variableChangedEvent !== null &&\n      oldValue !== null &&\n      value !== oldValue.result\n    ) {\n      if (this.batchObservingVariableChanges) {\n        if (this._changedVariablesForBatchObs === null) {\n          return throwNullException(\"this._changedVariablesForBatchObs\");\n        }\n\n        if (this.patch !== null) {\n          this.patch.AddChangedVariable(variableName);\n        } else if (this._changedVariablesForBatchObs !== null) {\n          this._changedVariablesForBatchObs.add(variableName);\n        }\n      } else {\n        this.variableChangedEvent(variableName, value);\n      }\n    }\n  }\n\n  public ResolveVariablePointer(varPointer: VariablePointerValue) {\n    let contextIndex = varPointer.contextIndex;\n\n    if (contextIndex == -1)\n      contextIndex = this.GetContextIndexOfVariableNamed(\n        varPointer.variableName\n      );\n\n    let valueOfVariablePointedTo = this.GetRawVariableWithName(\n      varPointer.variableName,\n      contextIndex\n    );\n\n    // var doubleRedirectionPointer = valueOfVariablePointedTo as VariablePointerValue;\n    let doubleRedirectionPointer = asOrNull(\n      valueOfVariablePointedTo,\n      VariablePointerValue\n    );\n    if (doubleRedirectionPointer != null) {\n      return doubleRedirectionPointer;\n    } else {\n      return new VariablePointerValue(varPointer.variableName, contextIndex);\n    }\n  }\n\n  public GetContextIndexOfVariableNamed(varName: string) {\n    if (this.GlobalVariableExistsWithName(varName)) return 0;\n\n    return this._callStack.currentElementIndex;\n  }\n\n  /**\n   * This function is specific to the js version of ink. It allows to register a\n   * callback that will be called when a variable changes. The original code uses\n   * `state.variableChangedEvent += callback` instead.\n   *\n   * @param {function} callback\n   */\n  public ObserveVariableChange(\n    callback: (variableName: string, newValue: InkObject) => void\n  ) {\n    this.variableChangedEventCallbacks.push(callback);\n  }\n\n  private _globalVariables: Map<string, InkObject>;\n  private _defaultGlobalVariables: Map<string, InkObject> = new Map();\n\n  private _callStack: CallStack;\n  private _changedVariablesForBatchObs: Set<string> | null = new Set();\n  private _listDefsOrigin: ListDefinitionsOrigin | null;\n}\n","// Taken from https://gist.github.com/blixt/f17b47c62508be59987b\n// Ink uses a seedable PRNG of which there is none in native javascript.\nexport class PRNG {\n  private seed: number;\n\n  constructor(seed: number) {\n    this.seed = seed % 2147483647;\n    if (this.seed <= 0) this.seed += 2147483646;\n  }\n  public next(): number {\n    return (this.seed = (this.seed * 48271) % 2147483647);\n  }\n  public nextFloat(): number {\n    return (this.next() - 1) / 2147483646;\n  }\n}\n","import { InkObject } from \"./Object\";\nimport { Container } from \"./Container\";\n\nexport class StatePatch {\n  get globals() {\n    return this._globals;\n  }\n  get changedVariables() {\n    return this._changedVariables;\n  }\n  get visitCounts() {\n    return this._visitCounts;\n  }\n  get turnIndices() {\n    return this._turnIndices;\n  }\n\n  constructor();\n  constructor(toCopy: StatePatch | null);\n  constructor() {\n    if (arguments.length === 1 && arguments[0] !== null) {\n      let toCopy = arguments[0] as StatePatch;\n      this._globals = new Map(toCopy._globals);\n      this._changedVariables = new Set(toCopy._changedVariables);\n      this._visitCounts = new Map(toCopy._visitCounts);\n      this._turnIndices = new Map(toCopy._turnIndices);\n    } else {\n      this._globals = new Map();\n      this._changedVariables = new Set();\n      this._visitCounts = new Map();\n      this._turnIndices = new Map();\n    }\n  }\n\n  public TryGetGlobal(name: string | null, /* out */ value: InkObject | null) {\n    if (name !== null && this._globals.has(name)) {\n      return { result: this._globals.get(name), exists: true };\n    }\n\n    return { result: value, exists: false };\n  }\n\n  public SetGlobal(name: string, value: InkObject) {\n    this._globals.set(name, value);\n  }\n\n  public AddChangedVariable(name: string) {\n    return this._changedVariables.add(name);\n  }\n\n  public TryGetVisitCount(container: Container, /* out */ count: number) {\n    if (this._visitCounts.has(container)) {\n      return { result: this._visitCounts.get(container), exists: true };\n    }\n\n    return { result: count, exists: false };\n  }\n\n  public SetVisitCount(container: Container, count: number) {\n    this._visitCounts.set(container, count);\n  }\n\n  public SetTurnIndex(container: Container, index: number) {\n    this._turnIndices.set(container, index);\n  }\n\n  public TryGetTurnIndex(container: Container, /* out */ index: number) {\n    if (this._turnIndices.has(container)) {\n      return { result: this._turnIndices.get(container), exists: true };\n    }\n\n    return { result: index, exists: false };\n  }\n\n  private _globals: Map<string, InkObject>;\n  private _changedVariables: Set<string> = new Set();\n  private _visitCounts: Map<Container, number> = new Map();\n  private _turnIndices: Map<Container, number> = new Map();\n}\n","export class SimpleJson {\n  public static TextToDictionary(text: string) {\n    return new SimpleJson.Reader(text).ToDictionary();\n  }\n\n  public static TextToArray(text: string) {\n    return new SimpleJson.Reader(text).ToArray();\n  }\n}\n\nexport namespace SimpleJson {\n  export class Reader {\n    constructor(text: string) {\n      this._rootObject = JSON.parse(text);\n    }\n\n    public ToDictionary() {\n      return this._rootObject as Record<string, any>;\n    }\n\n    public ToArray() {\n      return this._rootObject as any[];\n    }\n\n    private _rootObject: any[] | Record<string, any>;\n  }\n\n  // In C#, this class writes json tokens directly to a StringWriter or\n  // another stream. Here, a temporary hierarchy is created in the form\n  // of a javascript object, which is serialised in the `toString` method.\n  // See individual methods and properties for more information.\n  export class Writer {\n    public WriteObject(inner: (w: Writer) => void) {\n      this.WriteObjectStart();\n      inner(this);\n      this.WriteObjectEnd();\n    }\n\n    // Add a new object.\n    public WriteObjectStart() {\n      this.StartNewObject(true);\n\n      let newObject: Record<string, any> = {};\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This object is created as the value of a property,\n        // inside an other object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This object is created as the child of an array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This object is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Object)\n      );\n    }\n\n    public WriteObjectEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Write a property name / value pair to the current object.\n    public WriteProperty(\n      name: any,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      innerOrContent: ((w: Writer) => void) | string | boolean | null\n    ) {\n      this.WritePropertyStart(name);\n      if (arguments[1] instanceof Function) {\n        let inner = arguments[1];\n        inner(this);\n      } else {\n        let content: string | boolean | null = arguments[1];\n        this.Write(content);\n      }\n      this.WritePropertyEnd();\n    }\n\n    // Int and Float are separate calls, since there both are\n    // numbers in JavaScript, but need to be handled differently.\n\n    public WriteIntProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteInt(content);\n      this.WritePropertyEnd();\n    }\n\n    public WriteFloatProperty(name: any, content: number) {\n      this.WritePropertyStart(name);\n      this.WriteFloat(content);\n      this.WritePropertyEnd();\n    }\n\n    // Prepare a new property name, which will be use to add the\n    // new object when calling _addToCurrentObject() from a Write\n    // method.\n    public WritePropertyStart(name: any) {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this._propertyNameStack.push(name);\n\n      this.IncrementChildCount();\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n    }\n\n    public WritePropertyEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Property);\n      this.Assert(this.childCount === 1);\n      this._stateStack.pop();\n    }\n\n    // Prepare a new property name, except this time, the property name\n    // will be created by concatenating all the strings passed to\n    // WritePropertyNameInner.\n    public WritePropertyNameStart() {\n      this.Assert(this.state === SimpleJson.Writer.State.Object);\n      this.IncrementChildCount();\n\n      this._currentPropertyName = \"\";\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Property)\n      );\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.PropertyName)\n      );\n    }\n\n    public WritePropertyNameEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._propertyNameStack.push(this._currentPropertyName!);\n      this._currentPropertyName = null;\n      this._stateStack.pop();\n    }\n\n    public WritePropertyNameInner(str: string) {\n      this.Assert(this.state === SimpleJson.Writer.State.PropertyName);\n      this.Assert(this._currentPropertyName !== null);\n      this._currentPropertyName += str;\n    }\n\n    // Add a new array.\n    public WriteArrayStart() {\n      this.StartNewObject(true);\n\n      let newObject: any[] = [];\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        // This array is created as the value of a property,\n        // inside an object.\n        this.Assert(this.currentCollection !== null);\n        this.Assert(this.currentPropertyName !== null);\n\n        let propertyName = this._propertyNameStack.pop();\n        this.currentCollection![propertyName!] = newObject;\n        this._collectionStack.push(newObject);\n      } else if (this.state === SimpleJson.Writer.State.Array) {\n        // This array is created as the child of another array.\n        this.Assert(this.currentCollection !== null);\n\n        this.currentCollection!.push(newObject);\n        this._collectionStack.push(newObject);\n      } else {\n        // This array is the root object.\n        this.Assert(this.state === SimpleJson.Writer.State.None);\n        this._jsonObject = newObject;\n        this._collectionStack.push(newObject);\n      }\n\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.Array)\n      );\n    }\n\n    public WriteArrayEnd() {\n      this.Assert(this.state === SimpleJson.Writer.State.Array);\n      this._collectionStack.pop();\n      this._stateStack.pop();\n    }\n\n    // Add the value to the appropriate collection (array / object), given the current\n    // context.\n    public Write(\n      value: number | string | boolean | null,\n      // eslint-disable-next-line @typescript-eslint/no-unused-vars\n      escape: boolean = true\n    ) {\n      if (value === null) {\n        console.error(\"Warning: trying to write a null value\");\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteBool(value: boolean | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      this._addToCurrentObject(value);\n    }\n\n    public WriteInt(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n\n      // Math.floor is used as a precaution:\n      //     1. to ensure that the value is written as an integer\n      //        (without a fractional part -> 1 instead of 1.0), even\n      //        though it should be the default behaviour of\n      //        JSON.serialize;\n      //     2. to ensure that if a floating number is passed\n      //        accidentally, it's converted to an integer.\n      //\n      // This guarantees savegame compatibility with the reference\n      // implementation.\n      this._addToCurrentObject(Math.floor(value));\n    }\n\n    // Since JSON doesn't support NaN and Infinity, these values\n    // are converted here.\n    public WriteFloat(value: number | null) {\n      if (value === null) {\n        return;\n      }\n\n      this.StartNewObject(false);\n      if (value == Number.POSITIVE_INFINITY) {\n        this._addToCurrentObject(3.4e38);\n      } else if (value == Number.NEGATIVE_INFINITY) {\n        this._addToCurrentObject(-3.4e38);\n      } else if (isNaN(value)) {\n        this._addToCurrentObject(0.0);\n      } else {\n        this._addToCurrentObject(value);\n      }\n    }\n\n    public WriteNull() {\n      this.StartNewObject(false);\n      this._addToCurrentObject(null);\n    }\n\n    // Prepare a string before adding it to the current collection in\n    // WriteStringEnd(). The string will be a concatenation of all the\n    // strings passed to WriteStringInner.\n    public WriteStringStart() {\n      this.StartNewObject(false);\n      this._currentString = \"\";\n      this._stateStack.push(\n        new SimpleJson.Writer.StateElement(SimpleJson.Writer.State.String)\n      );\n    }\n\n    public WriteStringEnd() {\n      this.Assert(this.state == SimpleJson.Writer.State.String);\n      this._stateStack.pop();\n      this._addToCurrentObject(this._currentString);\n      this._currentString = null;\n    }\n\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    public WriteStringInner(str: string | null, escape: boolean = true) {\n      this.Assert(this.state === SimpleJson.Writer.State.String);\n\n      if (str === null) {\n        console.error(\"Warning: trying to write a null string\");\n        return;\n      }\n\n      this._currentString += str;\n    }\n\n    // Serialise the root object into a JSON string.\n    public toString() {\n      if (this._jsonObject === null) {\n        return \"\";\n      }\n\n      return JSON.stringify(this._jsonObject);\n    }\n\n    // Prepare the state stack when adding new objects / values.\n    private StartNewObject(container: boolean) {\n      if (container) {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.None ||\n            this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      } else {\n        this.Assert(\n          this.state === SimpleJson.Writer.State.Property ||\n            this.state === SimpleJson.Writer.State.Array\n        );\n      }\n\n      if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(this.childCount === 0);\n      }\n\n      if (\n        this.state === SimpleJson.Writer.State.Array ||\n        this.state === SimpleJson.Writer.State.Property\n      ) {\n        this.IncrementChildCount();\n      }\n    }\n\n    // These getters peek all the different stacks.\n\n    private get state() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].type;\n      } else {\n        return SimpleJson.Writer.State.None;\n      }\n    }\n\n    private get childCount() {\n      if (this._stateStack.length > 0) {\n        return this._stateStack[this._stateStack.length - 1].childCount;\n      } else {\n        return 0;\n      }\n    }\n\n    private get currentCollection() {\n      if (this._collectionStack.length > 0) {\n        return this._collectionStack[this._collectionStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private get currentPropertyName() {\n      if (this._propertyNameStack.length > 0) {\n        return this._propertyNameStack[this._propertyNameStack.length - 1];\n      } else {\n        return null;\n      }\n    }\n\n    private IncrementChildCount() {\n      this.Assert(this._stateStack.length > 0);\n      let currEl = this._stateStack.pop()!;\n      currEl.childCount++;\n      this._stateStack.push(currEl);\n    }\n\n    private Assert(condition: boolean) {\n      if (!condition) throw Error(\"Assert failed while writing JSON\");\n    }\n\n    // This method did not exist in the original C# code. It adds\n    // the given value to the current collection (used by Write methods).\n    private _addToCurrentObject(value: number | string | boolean | null) {\n      this.Assert(this.currentCollection !== null);\n      if (this.state === SimpleJson.Writer.State.Array) {\n        this.Assert(Array.isArray(this.currentCollection));\n        (this.currentCollection as any[]).push(value);\n      } else if (this.state === SimpleJson.Writer.State.Property) {\n        this.Assert(!Array.isArray(this.currentCollection));\n        this.Assert(this.currentPropertyName !== null);\n        (this.currentCollection as Record<string, any>)[\n          this.currentPropertyName!\n        ] = value;\n        this._propertyNameStack.pop();\n      }\n    }\n\n    // In addition to `_stateStack` present in the original code,\n    // this implementation of SimpleJson use two other stacks and two\n    // temporary variables holding the current context.\n\n    // Used to keep track of the current property name being built\n    // with `WritePropertyNameStart`, `WritePropertyNameInner` and\n    // `WritePropertyNameEnd`.\n    private _currentPropertyName: string | null = null;\n\n    // Used to keep track of the current string value being built\n    // with `WriteStringStart`, `WriteStringInner` and\n    // `WriteStringEnd`.\n    private _currentString: string | null = null;\n\n    private _stateStack: SimpleJson.Writer.StateElement[] = [];\n\n    // Keep track of the current collection being built (either an array\n    // or an object). For instance, at the '?' step during the hiarchy\n    // creation, this hierarchy:\n    // [3, {a: [b, ?]}] will have this corresponding stack:\n    // (bottom) [Array, Object, Array] (top)\n    private _collectionStack: Array<any[] | Record<string, any>> = [];\n\n    // Keep track of the current property being assigned. For instance, at\n    // the '?' step during the hiarchy creation, this hierarchy:\n    // [3, {a: [b, {c: ?}]}] will have this corresponding stack:\n    // (bottom) [a, c] (top)\n    private _propertyNameStack: string[] = [];\n\n    // Object containing the entire hiearchy.\n    private _jsonObject: Record<string, any> | any[] | null = null;\n  }\n\n  export namespace Writer {\n    export enum State {\n      None,\n      Object,\n      Array,\n      Property,\n      PropertyName,\n      String,\n    }\n\n    export class StateElement {\n      public type: SimpleJson.Writer.State = SimpleJson.Writer.State.None;\n      public childCount: number = 0;\n\n      constructor(type: SimpleJson.Writer.State) {\n        this.type = type;\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { Choice } from \"./Choice\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { InkObject } from \"./Object\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Story } from \"./Story\";\nimport { throwNullException } from \"./NullException\";\n\nexport class Flow {\n  public name: string;\n  public callStack: CallStack;\n  public outputStream: InkObject[];\n  public currentChoices: Choice[];\n\n  constructor(name: String, story: Story);\n  constructor(name: String, story: Story, jObject: Record<string, any>);\n  constructor() {\n    let name = arguments[0] as string;\n    let story = arguments[1] as Story;\n\n    this.name = name;\n    this.callStack = new CallStack(story);\n\n    if (arguments[2]) {\n      let jObject = arguments[2] as Record<string, any>;\n\n      this.callStack.SetJsonToken(jObject[\"callstack\"], story);\n      this.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"]\n      );\n      this.currentChoices = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"currentChoices\"]\n      ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      if (typeof jChoiceThreadsObj !== \"undefined\") {\n        this.LoadFlowChoiceThreads(jChoiceThreadsObj, story);\n      }\n    } else {\n      this.outputStream = [];\n      this.currentChoices = [];\n    }\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WriteProperty(\"callstack\", (w) => this.callStack.WriteJson(w));\n    writer.WriteProperty(\"outputStream\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.outputStream)\n    );\n\n    let hasChoiceThreads = false;\n    for (let c of this.currentChoices) {\n      if (c.threadAtGeneration === null)\n        return throwNullException(\"c.threadAtGeneration\");\n\n      c.originalThreadIndex = c.threadAtGeneration.threadIndex;\n\n      if (this.callStack.ThreadWithIndex(c.originalThreadIndex) === null) {\n        if (!hasChoiceThreads) {\n          hasChoiceThreads = true;\n          writer.WritePropertyStart(\"choiceThreads\");\n          writer.WriteObjectStart();\n        }\n\n        writer.WritePropertyStart(c.originalThreadIndex);\n        c.threadAtGeneration.WriteJson(writer);\n        writer.WritePropertyEnd();\n      }\n    }\n\n    if (hasChoiceThreads) {\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteProperty(\"currentChoices\", (w) => {\n      w.WriteArrayStart();\n      for (let c of this.currentChoices) {\n        JsonSerialisation.WriteChoice(w, c);\n      }\n      w.WriteArrayEnd();\n    });\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadFlowChoiceThreads(\n    jChoiceThreads: Record<string, any>,\n    story: Story\n  ) {\n    for (let choice of this.currentChoices) {\n      let foundActiveThread = this.callStack.ThreadWithIndex(\n        choice.originalThreadIndex\n      );\n      if (foundActiveThread !== null) {\n        choice.threadAtGeneration = foundActiveThread.Copy();\n      } else {\n        let jSavedChoiceThread =\n          jChoiceThreads[`${choice.originalThreadIndex}`];\n        choice.threadAtGeneration = new CallStack.Thread(\n          jSavedChoiceThread,\n          story\n        );\n      }\n    }\n  }\n}\n","import { CallStack } from \"./CallStack\";\nimport { VariablesState } from \"./VariablesState\";\nimport { ValueType, Value, StringValue, ListValue } from \"./Value\";\nimport { PushPopType } from \"./PushPop\";\nimport { Tag } from \"./Tag\";\nimport { Glue } from \"./Glue\";\nimport { Path } from \"./Path\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { PRNG } from \"./PRNG\";\nimport { Void } from \"./Void\";\nimport { Pointer } from \"./Pointer\";\nimport { tryGetValueFromMap } from \"./TryGetResult\";\nimport { Choice } from \"./Choice\";\nimport { asOrNull, asOrThrows, nullIfUndefined } from \"./TypeAssertion\";\nimport { Debug } from \"./Debug\";\nimport { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { throwNullException } from \"./NullException\";\nimport { Story } from \"./Story\";\nimport { StatePatch } from \"./StatePatch\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { Flow } from \"./Flow\";\nimport { InkList } from \"./InkList\";\n\nexport class StoryState {\n  // Backward compatible changes since v8:\n  // v10: dynamic tags\n  // v9:  multi-flows\n  public readonly kInkSaveStateVersion = 10;\n  public readonly kMinCompatibleLoadVersion = 8;\n\n  public onDidLoadState: (() => void) | null = null;\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  public ToJson(indented: boolean = false) {\n    let writer = new SimpleJson.Writer();\n    this.WriteJson(writer);\n    return writer.toString();\n  }\n  public toJson(indented: boolean = false) {\n    return this.ToJson(indented);\n  }\n\n  public LoadJson(json: string) {\n    let jObject = SimpleJson.TextToDictionary(json);\n    this.LoadJsonObj(jObject);\n    if (this.onDidLoadState !== null) this.onDidLoadState();\n  }\n\n  public VisitCountAtPathString(pathString: string) {\n    let visitCountOut;\n\n    if (this._patch !== null) {\n      let container = this.story.ContentAtPath(new Path(pathString)).container;\n      if (container === null)\n        throw new Error(\"Content at path not found: \" + pathString);\n\n      visitCountOut = this._patch.TryGetVisitCount(container, 0);\n      if (visitCountOut.exists) return visitCountOut.result;\n    }\n\n    visitCountOut = tryGetValueFromMap(this._visitCounts, pathString, null);\n    if (visitCountOut.exists) return visitCountOut.result;\n\n    return 0;\n  }\n\n  public VisitCountForContainer(container: Container | null): number {\n    if (container === null) {\n      return throwNullException(\"container\");\n    }\n    if (!container.visitsShouldBeCounted) {\n      this.story.Error(\n        \"Read count for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n      return 0;\n    }\n\n    if (this._patch !== null) {\n      let count = this._patch.TryGetVisitCount(container, 0);\n      if (count.exists) {\n        return count.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let count2 = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count2.exists) {\n      return count2.result!;\n    }\n\n    return 0;\n  }\n\n  public IncrementVisitCountForContainer(container: Container) {\n    if (this._patch !== null) {\n      let currCount = this.VisitCountForContainer(container);\n      currCount++;\n      this._patch.SetVisitCount(container, currCount);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    let count = tryGetValueFromMap(this._visitCounts, containerPathStr, null);\n    if (count.exists) {\n      this._visitCounts.set(containerPathStr, count.result! + 1);\n    } else {\n      this._visitCounts.set(containerPathStr, 1);\n    }\n  }\n\n  public RecordTurnIndexVisitToContainer(container: Container) {\n    if (this._patch !== null) {\n      this._patch.SetTurnIndex(container, this.currentTurnIndex);\n      return;\n    }\n\n    let containerPathStr = container.path.toString();\n    this._turnIndices.set(containerPathStr, this.currentTurnIndex);\n  }\n\n  public TurnsSinceForContainer(container: Container) {\n    if (!container.turnIndexShouldBeCounted) {\n      this.story.Error(\n        \"TURNS_SINCE() for target (\" +\n          container.name +\n          \" - on \" +\n          container.debugMetadata +\n          \") unknown. The story may need to be compiled with countAllVisits flag (-c).\"\n      );\n    }\n\n    if (this._patch !== null) {\n      let index = this._patch.TryGetTurnIndex(container, 0);\n      if (index.exists) {\n        return this.currentTurnIndex - index.result!;\n      }\n    }\n\n    let containerPathStr = container.path.toString();\n    let index2 = tryGetValueFromMap(this._turnIndices, containerPathStr, 0);\n    if (index2.exists) {\n      return this.currentTurnIndex - index2.result!;\n    } else {\n      return -1;\n    }\n  }\n\n  get callstackDepth() {\n    return this.callStack.depth;\n  }\n\n  get outputStream() {\n    return this._currentFlow.outputStream;\n  }\n\n  get currentChoices() {\n    // If we can continue generating text content rather than choices,\n    // then we reflect the choice list as being empty, since choices\n    // should always come at the end.\n    if (this.canContinue) return [];\n    return this._currentFlow.currentChoices;\n  }\n\n  get generatedChoices() {\n    return this._currentFlow.currentChoices;\n  }\n\n  get currentErrors() {\n    return this._currentErrors;\n  }\n  private _currentErrors: string[] | null = null;\n\n  get currentWarnings() {\n    return this._currentWarnings;\n  }\n  private _currentWarnings: string[] | null = null;\n\n  get variablesState() {\n    return this._variablesState;\n  }\n  set variablesState(value) {\n    this._variablesState = value;\n  }\n  private _variablesState: VariablesState;\n\n  get callStack() {\n    return this._currentFlow.callStack;\n  }\n\n  get evaluationStack() {\n    return this._evaluationStack;\n  }\n  private _evaluationStack: InkObject[];\n\n  public divertedPointer: Pointer = Pointer.Null;\n\n  get currentTurnIndex() {\n    return this._currentTurnIndex;\n  }\n  set currentTurnIndex(value) {\n    this._currentTurnIndex = value;\n  }\n  private _currentTurnIndex: number = 0;\n\n  public storySeed: number = 0;\n  public previousRandom: number = 0;\n  public didSafeExit: boolean = false;\n\n  public story: Story;\n\n  get currentPathString() {\n    let pointer = this.currentPointer;\n    if (pointer.isNull) {\n      return null;\n    } else {\n      if (pointer.path === null) {\n        return throwNullException(\"pointer.path\");\n      }\n      return pointer.path.toString();\n    }\n  }\n\n  get currentPointer() {\n    return this.callStack.currentElement.currentPointer.copy();\n  }\n\n  set currentPointer(value) {\n    this.callStack.currentElement.currentPointer = value.copy();\n  }\n\n  get previousPointer() {\n    return this.callStack.currentThread.previousPointer.copy();\n  }\n\n  set previousPointer(value) {\n    this.callStack.currentThread.previousPointer = value.copy();\n  }\n\n  get canContinue() {\n    return !this.currentPointer.isNull && !this.hasError;\n  }\n\n  get hasError() {\n    return this.currentErrors != null && this.currentErrors.length > 0;\n  }\n\n  get hasWarning() {\n    return this.currentWarnings != null && this.currentWarnings.length > 0;\n  }\n\n  get currentText() {\n    if (this._outputStreamTextDirty) {\n      let sb = new StringBuilder();\n\n      let inTag: boolean = false;\n\n      for (let outputObj of this.outputStream) {\n        // var textContent = outputObj as StringValue;\n        let textContent = asOrNull(outputObj, StringValue);\n        if (!inTag && textContent !== null) {\n          sb.Append(textContent.value);\n        } else {\n          let controlCommand = asOrNull(outputObj, ControlCommand);\n          if (controlCommand !== null) {\n            if (\n              controlCommand.commandType == ControlCommand.CommandType.BeginTag\n            ) {\n              inTag = true;\n            } else if (\n              controlCommand.commandType == ControlCommand.CommandType.EndTag\n            ) {\n              inTag = false;\n            }\n          }\n        }\n      }\n\n      this._currentText = this.CleanOutputWhitespace(sb.toString());\n      this._outputStreamTextDirty = false;\n    }\n\n    return this._currentText;\n  }\n  private _currentText: string | null = null;\n\n  public CleanOutputWhitespace(str: string) {\n    let sb = new StringBuilder();\n\n    let currentWhitespaceStart = -1;\n    let startOfLine = 0;\n\n    for (let i = 0; i < str.length; i++) {\n      let c = str.charAt(i);\n\n      let isInlineWhitespace = c == \" \" || c == \"\\t\";\n\n      if (isInlineWhitespace && currentWhitespaceStart == -1)\n        currentWhitespaceStart = i;\n\n      if (!isInlineWhitespace) {\n        if (\n          c != \"\\n\" &&\n          currentWhitespaceStart > 0 &&\n          currentWhitespaceStart != startOfLine\n        ) {\n          sb.Append(\" \");\n        }\n        currentWhitespaceStart = -1;\n      }\n\n      if (c == \"\\n\") startOfLine = i + 1;\n\n      if (!isInlineWhitespace) sb.Append(c);\n    }\n\n    return sb.toString();\n  }\n\n  get currentTags() {\n    if (this._outputStreamTagsDirty) {\n      this._currentTags = [];\n      let inTag: boolean = false;\n      let sb = new StringBuilder();\n\n      for (let outputObj of this.outputStream) {\n        let controlCommand = asOrNull(outputObj, ControlCommand);\n        if (controlCommand != null) {\n          if (\n            controlCommand.commandType == ControlCommand.CommandType.BeginTag\n          ) {\n            if (inTag && sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = true;\n          } else if (\n            controlCommand.commandType == ControlCommand.CommandType.EndTag\n          ) {\n            if (sb.Length > 0) {\n              let txt = this.CleanOutputWhitespace(sb.toString());\n              this._currentTags.push(txt);\n              sb.Clear();\n            }\n            inTag = false;\n          }\n        } else if (inTag) {\n          let strVal = asOrNull(outputObj, StringValue);\n          if (strVal !== null) {\n            sb.Append(strVal.value);\n          }\n        } else {\n          let tag = asOrNull(outputObj, Tag);\n          if (tag != null && tag.text != null && tag.text.length > 0) {\n            this._currentTags.push(tag.text); // tag.text has whitespae already cleaned\n          }\n        }\n      }\n\n      if (sb.Length > 0) {\n        let txt = this.CleanOutputWhitespace(sb.toString());\n        this._currentTags.push(txt);\n        sb.Clear();\n      }\n\n      this._outputStreamTagsDirty = false;\n    }\n\n    return this._currentTags;\n  }\n  private _currentTags: string[] | null = null;\n\n  get currentFlowName() {\n    return this._currentFlow.name;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this._currentFlow.name == this.kDefaultFlowName;\n  }\n\n  get aliveFlowNames() {\n    if (this._aliveFlowNamesDirty) {\n      this._aliveFlowNames = [];\n\n      if (this._namedFlows != null) {\n        for (let flowName of this._namedFlows.keys()) {\n          if (flowName != this.kDefaultFlowName) {\n            this._aliveFlowNames.push(flowName);\n          }\n        }\n      }\n\n      this._aliveFlowNamesDirty = false;\n    }\n\n    return this._aliveFlowNames;\n  }\n\n  get inExpressionEvaluation() {\n    return this.callStack.currentElement.inExpressionEvaluation;\n  }\n  set inExpressionEvaluation(value) {\n    this.callStack.currentElement.inExpressionEvaluation = value;\n  }\n\n  constructor(story: Story) {\n    this.story = story;\n\n    this._currentFlow = new Flow(this.kDefaultFlowName, story);\n    this.OutputStreamDirty();\n\n    this._aliveFlowNamesDirty = true;\n    this._evaluationStack = [];\n\n    this._variablesState = new VariablesState(\n      this.callStack,\n      story.listDefinitions\n    );\n\n    this._visitCounts = new Map();\n    this._turnIndices = new Map();\n    this.currentTurnIndex = -1;\n\n    let timeSeed = new Date().getTime();\n    this.storySeed = new PRNG(timeSeed).next() % 100;\n    this.previousRandom = 0;\n\n    this.GoToStart();\n  }\n\n  public GoToStart() {\n    this.callStack.currentElement.currentPointer = Pointer.StartOf(\n      this.story.mainContentContainer\n    );\n  }\n\n  public SwitchFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.SwitchFlow\");\n\n    if (this._namedFlows === null) {\n      this._namedFlows = new Map();\n      this._namedFlows.set(this.kDefaultFlowName, this._currentFlow);\n    }\n\n    if (flowName === this._currentFlow.name) {\n      return;\n    }\n\n    let flow: Flow;\n    let content = tryGetValueFromMap(this._namedFlows, flowName, null);\n    if (content.exists) {\n      flow = content.result!;\n    } else {\n      flow = new Flow(flowName, this.story);\n      this._namedFlows.set(flowName, flow);\n      this._aliveFlowNamesDirty = true;\n    }\n\n    this._currentFlow = flow;\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this.OutputStreamDirty();\n  }\n\n  public SwitchToDefaultFlow_Internal() {\n    if (this._namedFlows === null) return;\n    this.SwitchFlow_Internal(this.kDefaultFlowName);\n  }\n\n  public RemoveFlow_Internal(flowName: string | null) {\n    if (flowName === null)\n      throw new Error(\"Must pass a non-null string to Story.DestroyFlow\");\n    if (flowName === this.kDefaultFlowName)\n      throw new Error(\"Cannot destroy default flow\");\n\n    if (this._currentFlow.name === flowName) {\n      this.SwitchToDefaultFlow_Internal();\n    }\n\n    if (this._namedFlows === null)\n      return throwNullException(\"this._namedFlows\");\n    this._namedFlows.delete(flowName);\n    this._aliveFlowNamesDirty = true;\n  }\n\n  public CopyAndStartPatching() {\n    let copy = new StoryState(this.story);\n\n    copy._patch = new StatePatch(this._patch);\n\n    copy._currentFlow.name = this._currentFlow.name;\n    copy._currentFlow.callStack = new CallStack(this._currentFlow.callStack);\n    copy._currentFlow.currentChoices.push(...this._currentFlow.currentChoices);\n    copy._currentFlow.outputStream.push(...this._currentFlow.outputStream);\n    copy.OutputStreamDirty();\n\n    if (this._namedFlows !== null) {\n      copy._namedFlows = new Map();\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        copy._namedFlows.set(namedFlowKey, namedFlowValue);\n        copy._aliveFlowNamesDirty = true;\n      }\n      copy._namedFlows.set(this._currentFlow.name, copy._currentFlow);\n    }\n\n    if (this.hasError) {\n      copy._currentErrors = [];\n      copy._currentErrors.push(...(this.currentErrors || []));\n    }\n\n    if (this.hasWarning) {\n      copy._currentWarnings = [];\n      copy._currentWarnings.push(...(this.currentWarnings || []));\n    }\n\n    copy.variablesState = this.variablesState;\n    copy.variablesState.callStack = copy.callStack;\n    copy.variablesState.patch = copy._patch;\n\n    copy.evaluationStack.push(...this.evaluationStack);\n\n    if (!this.divertedPointer.isNull)\n      copy.divertedPointer = this.divertedPointer.copy();\n\n    copy.previousPointer = this.previousPointer.copy();\n\n    copy._visitCounts = this._visitCounts;\n    copy._turnIndices = this._turnIndices;\n\n    copy.currentTurnIndex = this.currentTurnIndex;\n    copy.storySeed = this.storySeed;\n    copy.previousRandom = this.previousRandom;\n\n    copy.didSafeExit = this.didSafeExit;\n\n    return copy;\n  }\n\n  public RestoreAfterPatch() {\n    this.variablesState.callStack = this.callStack;\n    this.variablesState.patch = this._patch;\n  }\n\n  public ApplyAnyPatch() {\n    if (this._patch === null) return;\n\n    this.variablesState.ApplyPatch();\n\n    for (let [key, value] of this._patch.visitCounts)\n      this.ApplyCountChanges(key, value, true);\n\n    for (let [key, value] of this._patch.turnIndices)\n      this.ApplyCountChanges(key, value, false);\n\n    this._patch = null;\n  }\n\n  public ApplyCountChanges(\n    container: Container,\n    newCount: number,\n    isVisit: boolean\n  ) {\n    let counts = isVisit ? this._visitCounts : this._turnIndices;\n    counts.set(container.path.toString(), newCount);\n  }\n\n  public WriteJson(writer: SimpleJson.Writer) {\n    writer.WriteObjectStart();\n\n    writer.WritePropertyStart(\"flows\");\n    writer.WriteObjectStart();\n\n    // NOTE: Never pass `WriteJson` directly as an argument to `WriteProperty`.\n    // Call it inside a function to make sure `this` is correctly bound\n    // and passed down the call hierarchy.\n\n    if (this._namedFlows !== null) {\n      for (let [namedFlowKey, namedFlowValue] of this._namedFlows) {\n        writer.WriteProperty(namedFlowKey, (w) => namedFlowValue.WriteJson(w));\n      }\n    } else {\n      writer.WriteProperty(this._currentFlow.name, (w) =>\n        this._currentFlow.WriteJson(w)\n      );\n    }\n\n    writer.WriteObjectEnd();\n    writer.WritePropertyEnd();\n\n    writer.WriteProperty(\"currentFlowName\", this._currentFlow.name);\n\n    writer.WriteProperty(\"variablesState\", (w) =>\n      this.variablesState.WriteJson(w)\n    );\n\n    writer.WriteProperty(\"evalStack\", (w) =>\n      JsonSerialisation.WriteListRuntimeObjs(w, this.evaluationStack)\n    );\n\n    if (!this.divertedPointer.isNull) {\n      if (this.divertedPointer.path === null) {\n        return throwNullException(\"divertedPointer\");\n      }\n      writer.WriteProperty(\n        \"currentDivertTarget\",\n        this.divertedPointer.path.componentsString\n      );\n    }\n\n    writer.WriteProperty(\"visitCounts\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._visitCounts)\n    );\n    writer.WriteProperty(\"turnIndices\", (w) =>\n      JsonSerialisation.WriteIntDictionary(w, this._turnIndices)\n    );\n\n    writer.WriteIntProperty(\"turnIdx\", this.currentTurnIndex);\n    writer.WriteIntProperty(\"storySeed\", this.storySeed);\n    writer.WriteIntProperty(\"previousRandom\", this.previousRandom);\n\n    writer.WriteIntProperty(\"inkSaveVersion\", this.kInkSaveStateVersion);\n\n    writer.WriteIntProperty(\"inkFormatVersion\", Story.inkVersionCurrent);\n\n    writer.WriteObjectEnd();\n  }\n\n  public LoadJsonObj(value: Record<string, any>) {\n    let jObject = value;\n\n    let jSaveVersion = jObject[\"inkSaveVersion\"];\n    if (jSaveVersion == null) {\n      throw new Error(\"ink save format incorrect, can't load.\");\n    } else if (parseInt(jSaveVersion) < this.kMinCompatibleLoadVersion) {\n      throw new Error(\n        \"Ink save format isn't compatible with the current version (saw '\" +\n          jSaveVersion +\n          \"', but minimum is \" +\n          this.kMinCompatibleLoadVersion +\n          \"), so can't load.\"\n      );\n    }\n\n    let flowsObj = jObject[\"flows\"];\n    if (flowsObj != null) {\n      let flowsObjDict = flowsObj as Record<string, any>;\n\n      // Single default flow\n      if (Object.keys(flowsObjDict).length === 1) {\n        this._namedFlows = null;\n      } else if (this._namedFlows === null) {\n        this._namedFlows = new Map();\n      } else {\n        this._namedFlows.clear();\n      }\n\n      let flowsObjDictEntries = Object.entries(flowsObjDict);\n      for (let [namedFlowObjKey, namedFlowObjValue] of flowsObjDictEntries) {\n        let name = namedFlowObjKey;\n        let flowObj = namedFlowObjValue as Record<string, any>;\n\n        let flow = new Flow(name, this.story, flowObj);\n\n        if (Object.keys(flowsObjDict).length === 1) {\n          this._currentFlow = new Flow(name, this.story, flowObj);\n        } else {\n          if (this._namedFlows === null)\n            return throwNullException(\"this._namedFlows\");\n          this._namedFlows.set(name, flow);\n        }\n      }\n\n      if (this._namedFlows != null && this._namedFlows.size > 1) {\n        let currFlowName = jObject[\"currentFlowName\"] as string;\n        // Adding a bang at the end, because we're trusting the save, as\n        // done in upstream.  If the save is corrupted, the execution\n        // is undefined.\n        this._currentFlow = this._namedFlows.get(currFlowName)!;\n      }\n    } else {\n      this._namedFlows = null;\n      this._currentFlow.name = this.kDefaultFlowName;\n      this._currentFlow.callStack.SetJsonToken(\n        jObject[\"callstackThreads\"] as Record<string, any>,\n        this.story\n      );\n      this._currentFlow.outputStream = JsonSerialisation.JArrayToRuntimeObjList(\n        jObject[\"outputStream\"] as any[]\n      );\n      this._currentFlow.currentChoices =\n        JsonSerialisation.JArrayToRuntimeObjList(\n          jObject[\"currentChoices\"] as any[]\n        ) as Choice[];\n\n      let jChoiceThreadsObj = jObject[\"choiceThreads\"];\n      this._currentFlow.LoadFlowChoiceThreads(jChoiceThreadsObj, this.story);\n    }\n\n    this.OutputStreamDirty();\n    this._aliveFlowNamesDirty = true;\n\n    this.variablesState.SetJsonToken(jObject[\"variablesState\"]);\n    this.variablesState.callStack = this._currentFlow.callStack;\n\n    this._evaluationStack = JsonSerialisation.JArrayToRuntimeObjList(\n      jObject[\"evalStack\"]\n    );\n\n    let currentDivertTargetPath = jObject[\"currentDivertTarget\"];\n    if (currentDivertTargetPath != null) {\n      let divertPath = new Path(currentDivertTargetPath.toString());\n      this.divertedPointer = this.story.PointerAtPath(divertPath);\n    }\n\n    this._visitCounts = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"visitCounts\"]\n    );\n    this._turnIndices = JsonSerialisation.JObjectToIntDictionary(\n      jObject[\"turnIndices\"]\n    );\n    this.currentTurnIndex = parseInt(jObject[\"turnIdx\"]);\n    this.storySeed = parseInt(jObject[\"storySeed\"]);\n    this.previousRandom = parseInt(jObject[\"previousRandom\"]);\n  }\n\n  public ResetErrors() {\n    this._currentErrors = null;\n    this._currentWarnings = null;\n  }\n  public ResetOutput(objs: InkObject[] | null = null) {\n    this.outputStream.length = 0;\n    if (objs !== null) this.outputStream.push(...objs);\n    this.OutputStreamDirty();\n  }\n\n  public PushToOutputStream(obj: InkObject | null) {\n    // var text = obj as StringValue;\n    let text = asOrNull(obj, StringValue);\n    if (text !== null) {\n      let listText = this.TrySplittingHeadTailWhitespace(text);\n      if (listText !== null) {\n        for (let textObj of listText) {\n          this.PushToOutputStreamIndividual(textObj);\n        }\n        this.OutputStreamDirty();\n        return;\n      }\n    }\n\n    this.PushToOutputStreamIndividual(obj);\n    this.OutputStreamDirty();\n  }\n\n  public PopFromOutputStream(count: number) {\n    this.outputStream.splice(this.outputStream.length - count, count);\n    this.OutputStreamDirty();\n  }\n\n  public TrySplittingHeadTailWhitespace(single: StringValue) {\n    let str = single.value;\n    if (str === null) {\n      return throwNullException(\"single.value\");\n    }\n\n    let headFirstNewlineIdx = -1;\n    let headLastNewlineIdx = -1;\n    for (let i = 0; i < str.length; i++) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (headFirstNewlineIdx == -1) headFirstNewlineIdx = i;\n        headLastNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    let tailLastNewlineIdx = -1;\n    let tailFirstNewlineIdx = -1;\n    for (let i = str.length - 1; i >= 0; i--) {\n      let c = str[i];\n      if (c == \"\\n\") {\n        if (tailLastNewlineIdx == -1) tailLastNewlineIdx = i;\n        tailFirstNewlineIdx = i;\n      } else if (c == \" \" || c == \"\\t\") continue;\n      else break;\n    }\n\n    // No splitting to be done?\n    if (headFirstNewlineIdx == -1 && tailLastNewlineIdx == -1) return null;\n\n    let listTexts: StringValue[] = [];\n    let innerStrStart = 0;\n    let innerStrEnd = str.length;\n\n    if (headFirstNewlineIdx != -1) {\n      if (headFirstNewlineIdx > 0) {\n        let leadingSpaces = new StringValue(\n          str.substring(0, headFirstNewlineIdx)\n        );\n        listTexts.push(leadingSpaces);\n      }\n      listTexts.push(new StringValue(\"\\n\"));\n      innerStrStart = headLastNewlineIdx + 1;\n    }\n\n    if (tailLastNewlineIdx != -1) {\n      innerStrEnd = tailFirstNewlineIdx;\n    }\n\n    if (innerStrEnd > innerStrStart) {\n      let innerStrText = str.substring(\n        innerStrStart,\n        innerStrEnd - innerStrStart\n      );\n      listTexts.push(new StringValue(innerStrText));\n    }\n\n    if (tailLastNewlineIdx != -1 && tailFirstNewlineIdx > headLastNewlineIdx) {\n      listTexts.push(new StringValue(\"\\n\"));\n      if (tailLastNewlineIdx < str.length - 1) {\n        let numSpaces = str.length - tailLastNewlineIdx - 1;\n        let trailingSpaces = new StringValue(\n          str.substring(tailLastNewlineIdx + 1, numSpaces)\n        );\n        listTexts.push(trailingSpaces);\n      }\n    }\n\n    return listTexts;\n  }\n\n  public PushToOutputStreamIndividual(obj: InkObject | null) {\n    let glue = asOrNull(obj, Glue);\n    let text = asOrNull(obj, StringValue);\n\n    let includeInOutput = true;\n\n    if (glue) {\n      this.TrimNewlinesFromOutputStream();\n      includeInOutput = true;\n    } else if (text) {\n      let functionTrimIndex = -1;\n      let currEl = this.callStack.currentElement;\n      if (currEl.type == PushPopType.Function) {\n        functionTrimIndex = currEl.functionStartInOutputStream;\n      }\n\n      let glueTrimIndex = -1;\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let o = this.outputStream[i];\n        let c = o instanceof ControlCommand ? o : null;\n        let g = o instanceof Glue ? o : null;\n\n        if (g != null) {\n          glueTrimIndex = i;\n          break;\n        } else if (\n          c != null &&\n          c.commandType == ControlCommand.CommandType.BeginString\n        ) {\n          if (i >= functionTrimIndex) {\n            functionTrimIndex = -1;\n          }\n          break;\n        }\n      }\n\n      let trimIndex = -1;\n      if (glueTrimIndex != -1 && functionTrimIndex != -1)\n        trimIndex = Math.min(functionTrimIndex, glueTrimIndex);\n      else if (glueTrimIndex != -1) trimIndex = glueTrimIndex;\n      else trimIndex = functionTrimIndex;\n\n      if (trimIndex != -1) {\n        if (text.isNewline) {\n          includeInOutput = false;\n        } else if (text.isNonWhitespace) {\n          if (glueTrimIndex > -1) this.RemoveExistingGlue();\n\n          if (functionTrimIndex > -1) {\n            let callStackElements = this.callStack.elements;\n            for (let i = callStackElements.length - 1; i >= 0; i--) {\n              let el = callStackElements[i];\n              if (el.type == PushPopType.Function) {\n                el.functionStartInOutputStream = -1;\n              } else {\n                break;\n              }\n            }\n          }\n        }\n      } else if (text.isNewline) {\n        if (this.outputStreamEndsInNewline || !this.outputStreamContainsContent)\n          includeInOutput = false;\n      }\n    }\n\n    if (includeInOutput) {\n      if (obj === null) {\n        return throwNullException(\"obj\");\n      }\n      this.outputStream.push(obj);\n      this.OutputStreamDirty();\n    }\n  }\n\n  public TrimNewlinesFromOutputStream() {\n    let removeWhitespaceFrom = -1;\n\n    let i = this.outputStream.length - 1;\n    while (i >= 0) {\n      let obj = this.outputStream[i];\n      let cmd = asOrNull(obj, ControlCommand);\n      let txt = asOrNull(obj, StringValue);\n\n      if (cmd != null || (txt != null && txt.isNonWhitespace)) {\n        break;\n      } else if (txt != null && txt.isNewline) {\n        removeWhitespaceFrom = i;\n      }\n      i--;\n    }\n\n    // Remove the whitespace\n    if (removeWhitespaceFrom >= 0) {\n      i = removeWhitespaceFrom;\n      while (i < this.outputStream.length) {\n        let text = asOrNull(this.outputStream[i], StringValue);\n        if (text) {\n          this.outputStream.splice(i, 1);\n        } else {\n          i++;\n        }\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  public RemoveExistingGlue() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let c = this.outputStream[i];\n      if (c instanceof Glue) {\n        this.outputStream.splice(i, 1);\n      } else if (c instanceof ControlCommand) {\n        break;\n      }\n    }\n\n    this.OutputStreamDirty();\n  }\n\n  get outputStreamEndsInNewline() {\n    if (this.outputStream.length > 0) {\n      for (let i = this.outputStream.length - 1; i >= 0; i--) {\n        let obj = this.outputStream[i];\n        if (obj instanceof ControlCommand) break;\n        let text = this.outputStream[i];\n        if (text instanceof StringValue) {\n          if (text.isNewline) return true;\n          else if (text.isNonWhitespace) break;\n        }\n      }\n    }\n\n    return false;\n  }\n\n  get outputStreamContainsContent() {\n    for (let content of this.outputStream) {\n      if (content instanceof StringValue) return true;\n    }\n    return false;\n  }\n\n  get inStringEvaluation() {\n    for (let i = this.outputStream.length - 1; i >= 0; i--) {\n      let cmd = asOrNull(this.outputStream[i], ControlCommand);\n      if (\n        cmd instanceof ControlCommand &&\n        cmd.commandType == ControlCommand.CommandType.BeginString\n      ) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public PushEvaluationStack(obj: InkObject | null) {\n    // var listValue = obj as ListValue;\n    let listValue = asOrNull(obj, ListValue);\n    if (listValue) {\n      // Update origin when list is has something to indicate the list origin\n      let rawList = listValue.value;\n      if (rawList === null) {\n        return throwNullException(\"rawList\");\n      }\n\n      if (rawList.originNames != null) {\n        if (!rawList.origins) rawList.origins = [];\n        rawList.origins.length = 0;\n\n        for (let n of rawList.originNames) {\n          if (this.story.listDefinitions === null)\n            return throwNullException(\"StoryState.story.listDefinitions\");\n          let def = this.story.listDefinitions.TryListGetDefinition(n, null);\n          if (def.result === null)\n            return throwNullException(\"StoryState def.result\");\n          if (rawList.origins.indexOf(def.result) < 0)\n            rawList.origins.push(def.result);\n        }\n      }\n    }\n\n    if (obj === null) {\n      return throwNullException(\"obj\");\n    }\n    this.evaluationStack.push(obj);\n  }\n\n  public PopEvaluationStack(): InkObject;\n  public PopEvaluationStack(numberOfObjects: number): InkObject[];\n  public PopEvaluationStack(numberOfObjects?: number) {\n    if (typeof numberOfObjects === \"undefined\") {\n      let obj = this.evaluationStack.pop();\n      return nullIfUndefined(obj);\n    } else {\n      if (numberOfObjects > this.evaluationStack.length) {\n        throw new Error(\"trying to pop too many objects\");\n      }\n\n      let popped = this.evaluationStack.splice(\n        this.evaluationStack.length - numberOfObjects,\n        numberOfObjects\n      );\n      return nullIfUndefined(popped);\n    }\n  }\n\n  public PeekEvaluationStack() {\n    return this.evaluationStack[this.evaluationStack.length - 1];\n  }\n\n  public ForceEnd() {\n    this.callStack.Reset();\n\n    this._currentFlow.currentChoices.length = 0;\n\n    this.currentPointer = Pointer.Null;\n    this.previousPointer = Pointer.Null;\n\n    this.didSafeExit = true;\n  }\n\n  public TrimWhitespaceFromFunctionEnd() {\n    Debug.Assert(this.callStack.currentElement.type == PushPopType.Function);\n    let functionStartPoint =\n      this.callStack.currentElement.functionStartInOutputStream;\n\n    if (functionStartPoint == -1) {\n      functionStartPoint = 0;\n    }\n\n    for (let i = this.outputStream.length - 1; i >= functionStartPoint; i--) {\n      let obj = this.outputStream[i];\n      let txt = asOrNull(obj, StringValue);\n      let cmd = asOrNull(obj, ControlCommand);\n\n      if (txt == null) continue;\n      if (cmd) break;\n\n      if (txt.isNewline || txt.isInlineWhitespace) {\n        this.outputStream.splice(i, 1);\n        this.OutputStreamDirty();\n      } else {\n        break;\n      }\n    }\n  }\n\n  public PopCallStack(popType: PushPopType | null = null) {\n    if (this.callStack.currentElement.type == PushPopType.Function)\n      this.TrimWhitespaceFromFunctionEnd();\n\n    this.callStack.Pop(popType);\n  }\n\n  public SetChosenPath(path: Path, incrementingTurnIndex: boolean) {\n    // Changing direction, assume we need to clear current set of choices\n    this._currentFlow.currentChoices.length = 0;\n\n    let newPointer = this.story.PointerAtPath(path);\n    if (!newPointer.isNull && newPointer.index == -1) newPointer.index = 0;\n\n    this.currentPointer = newPointer;\n\n    if (incrementingTurnIndex) {\n      this.currentTurnIndex++;\n    }\n  }\n\n  public StartFunctionEvaluationFromGame(\n    funcContainer: Container,\n    args: any[]\n  ) {\n    this.callStack.Push(\n      PushPopType.FunctionEvaluationFromGame,\n      this.evaluationStack.length\n    );\n    this.callStack.currentElement.currentPointer =\n      Pointer.StartOf(funcContainer);\n\n    this.PassArgumentsToEvaluationStack(args);\n  }\n\n  public PassArgumentsToEvaluationStack(args: any[] | null) {\n    if (args !== null) {\n      for (let i = 0; i < args.length; i++) {\n        if (\n          !(\n            typeof args[i] === \"number\" ||\n            typeof args[i] === \"string\" ||\n            typeof args[i] === \"boolean\" ||\n            args[i] instanceof InkList\n          )\n        ) {\n          throw new Error(\n            \"ink arguments when calling EvaluateFunction / ChoosePathStringWithParameters must be\" +\n            \"number, string, bool or InkList. Argument was \" +\n            (nullIfUndefined(arguments[i]) === null)\n              ? \"null\"\n              : arguments[i].constructor.name\n          );\n        }\n\n        this.PushEvaluationStack(Value.Create(args[i]));\n      }\n    }\n  }\n\n  public TryExitFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type ==\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      this.currentPointer = Pointer.Null;\n      this.didSafeExit = true;\n      return true;\n    }\n\n    return false;\n  }\n\n  public CompleteFunctionEvaluationFromGame() {\n    if (\n      this.callStack.currentElement.type !=\n      PushPopType.FunctionEvaluationFromGame\n    ) {\n      throw new Error(\n        \"Expected external function evaluation to be complete. Stack trace: \" +\n          this.callStack.callStackTrace\n      );\n    }\n\n    let originalEvaluationStackHeight =\n      this.callStack.currentElement.evaluationStackHeightWhenPushed;\n\n    let returnedObj: InkObject | null = null;\n    while (this.evaluationStack.length > originalEvaluationStackHeight) {\n      let poppedObj = this.PopEvaluationStack();\n      if (returnedObj === null) returnedObj = poppedObj;\n    }\n\n    this.PopCallStack(PushPopType.FunctionEvaluationFromGame);\n\n    if (returnedObj) {\n      if (returnedObj instanceof Void) return null;\n\n      // Some kind of value, if not void\n      // var returnVal = returnedObj as Runtime.Value;\n      let returnVal = asOrThrows(returnedObj, Value);\n\n      // DivertTargets get returned as the string of components\n      // (rather than a Path, which isn't public)\n      if (returnVal.valueType == ValueType.DivertTarget) {\n        return returnVal.valueObject.toString();\n      }\n\n      // Other types can just have their exact object type:\n      // int, float, string. VariablePointers get returned as strings.\n      return returnVal.valueObject;\n    }\n\n    return null;\n  }\n\n  public AddError(message: string, isWarning: boolean) {\n    if (!isWarning) {\n      if (this._currentErrors == null) this._currentErrors = [];\n      this._currentErrors.push(message);\n    } else {\n      if (this._currentWarnings == null) this._currentWarnings = [];\n      this._currentWarnings.push(message);\n    }\n  }\n\n  public OutputStreamDirty() {\n    this._outputStreamTextDirty = true;\n    this._outputStreamTagsDirty = true;\n  }\n\n  private _visitCounts: Map<string, number>;\n  private _turnIndices: Map<string, number>;\n\n  private _outputStreamTextDirty = true;\n  private _outputStreamTagsDirty = true;\n\n  private _patch: StatePatch | null = null;\n\n  private _currentFlow: Flow;\n  private _aliveFlowNames: string[] | null = null;\n  private _namedFlows: Map<string, Flow> | null = null;\n  private readonly kDefaultFlowName = \"DEFAULT_FLOW\";\n  private _aliveFlowNamesDirty: boolean = true;\n}\n","// This is simple replacement of the Stopwatch class from the .NET Framework.\n// The original class can count time with much more accuracy than the Javascript version.\n// It might be worth considering using `window.performance` in the browser\n// or `process.hrtime()` in node.\nexport class Stopwatch {\n  private startTime: number | undefined;\n\n  constructor() {\n    this.startTime = undefined;\n  }\n\n  get ElapsedMilliseconds(): number {\n    if (typeof this.startTime === \"undefined\") {\n      return 0;\n    }\n    return new Date().getTime() - this.startTime;\n  }\n\n  public Start() {\n    this.startTime = new Date().getTime();\n  }\n  public Stop() {\n    this.startTime = undefined;\n  }\n}\n","import { Container } from \"./Container\";\nimport { InkObject } from \"./Object\";\nimport { JsonSerialisation } from \"./JsonSerialisation\";\nimport { StoryState } from \"./StoryState\";\nimport { ControlCommand } from \"./ControlCommand\";\nimport { PushPopType } from \"./PushPop\";\nimport { ChoicePoint } from \"./ChoicePoint\";\nimport { Choice } from \"./Choice\";\nimport { Divert } from \"./Divert\";\nimport {\n  Value,\n  StringValue,\n  IntValue,\n  DivertTargetValue,\n  VariablePointerValue,\n  ListValue,\n} from \"./Value\";\nimport { Path } from \"./Path\";\nimport { Void } from \"./Void\";\nimport { Tag } from \"./Tag\";\nimport { VariableAssignment } from \"./VariableAssignment\";\nimport { VariableReference } from \"./VariableReference\";\nimport { NativeFunctionCall } from \"./NativeFunctionCall\";\nimport { StoryException } from \"./StoryException\";\nimport { PRNG } from \"./PRNG\";\nimport { StringBuilder } from \"./StringBuilder\";\nimport { ListDefinitionsOrigin } from \"./ListDefinitionsOrigin\";\nimport { ListDefinition } from \"./ListDefinition\";\nimport { Stopwatch } from \"./StopWatch\";\nimport { Pointer } from \"./Pointer\";\nimport { InkList, InkListItem, KeyValuePair } from \"./InkList\";\nimport { asOrNull, asOrThrows } from \"./TypeAssertion\";\nimport { DebugMetadata } from \"./DebugMetadata\";\nimport { throwNullException } from \"./NullException\";\nimport { SimpleJson } from \"./SimpleJson\";\nimport { ErrorHandler, ErrorType } from \"./Error\";\n\nexport { InkList } from \"./InkList\";\n\nif (!Number.isInteger) {\n  Number.isInteger = function isInteger(nVal: any) {\n    return (\n      typeof nVal === \"number\" &&\n      isFinite(nVal) &&\n      nVal > -9007199254740992 &&\n      nVal < 9007199254740992 &&\n      Math.floor(nVal) === nVal\n    );\n  };\n}\n\nexport class Story extends InkObject {\n  public static inkVersionCurrent = 21;\n\n  public inkVersionMinimumCompatible = 18;\n\n  get currentChoices() {\n    let choices: Choice[] = [];\n\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    for (let c of this._state.currentChoices) {\n      if (!c.isInvisibleDefault) {\n        c.index = choices.length;\n        choices.push(c);\n      }\n    }\n\n    return choices;\n  }\n\n  get currentText() {\n    this.IfAsyncWeCant(\"call currentText since it's a work in progress\");\n    return this.state.currentText;\n  }\n\n  get currentTags() {\n    this.IfAsyncWeCant(\"call currentTags since it's a work in progress\");\n    return this.state.currentTags;\n  }\n\n  get currentErrors() {\n    return this.state.currentErrors;\n  }\n\n  get currentWarnings() {\n    return this.state.currentWarnings;\n  }\n\n  get currentFlowName() {\n    return this.state.currentFlowName;\n  }\n\n  get currentFlowIsDefaultFlow() {\n    return this.state.currentFlowIsDefaultFlow;\n  }\n\n  get aliveFlowNames() {\n    return this.state.aliveFlowNames;\n  }\n\n  get hasError() {\n    return this.state.hasError;\n  }\n\n  get hasWarning() {\n    return this.state.hasWarning;\n  }\n\n  get variablesState() {\n    return this.state.variablesState;\n  }\n\n  get listDefinitions() {\n    return this._listDefinitions;\n  }\n\n  get state() {\n    return this._state;\n  }\n\n  public onError: ErrorHandler | null = null;\n\n  public onDidContinue: (() => void) | null = null;\n\n  public onMakeChoice: ((arg1: Choice) => void) | null = null;\n\n  public onEvaluateFunction: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  public onCompleteEvaluateFunction:\n    | ((arg1: string, arg2: any[], arg3: string, arg4: any) => void)\n    | null = null;\n\n  public onChoosePathString: ((arg1: string, arg2: any[]) => void) | null =\n    null;\n\n  // TODO: Implement Profiler\n  public StartProfiling() {\n    /* */\n  }\n  public EndProfiling() {\n    /* */\n  }\n\n  constructor(contentContainer: Container, lists: ListDefinition[] | null);\n  constructor(jsonString: string);\n  constructor(json: Record<string, any>);\n  constructor() {\n    super();\n\n    // Discrimination between constructors\n    let contentContainer: Container;\n    let lists: ListDefinition[] | null = null;\n    let json: Record<string, any> | null = null;\n\n    if (arguments[0] instanceof Container) {\n      contentContainer = arguments[0] as Container;\n\n      if (typeof arguments[1] !== \"undefined\") {\n        lists = arguments[1] as ListDefinition[];\n      }\n\n      // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n      this._mainContentContainer = contentContainer;\n      // ------\n    } else {\n      if (typeof arguments[0] === \"string\") {\n        let jsonString = arguments[0] as string;\n        json = SimpleJson.TextToDictionary(jsonString);\n      } else {\n        json = arguments[0] as Record<string, any>;\n      }\n    }\n\n    // ------ Story (Container contentContainer, List<Runtime.ListDefinition> lists = null)\n    if (lists != null) this._listDefinitions = new ListDefinitionsOrigin(lists);\n\n    this._externals = new Map();\n    // ------\n\n    // ------ Story(string jsonString) : this((Container)null)\n    if (json !== null) {\n      let rootObject: Record<string, any> = json;\n\n      let versionObj = rootObject[\"inkVersion\"];\n      if (versionObj == null)\n        throw new Error(\n          \"ink version number not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let formatFromFile = parseInt(versionObj);\n      if (formatFromFile > Story.inkVersionCurrent) {\n        throw new Error(\n          \"Version of ink used to build story was newer than the current version of the engine\"\n        );\n      } else if (formatFromFile < this.inkVersionMinimumCompatible) {\n        throw new Error(\n          \"Version of ink used to build story is too old to be loaded by this version of the engine\"\n        );\n      } else if (formatFromFile != Story.inkVersionCurrent) {\n        console.warn(\n          \"WARNING: Version of ink used to build story doesn't match current version of engine. Non-critical, but recommend synchronising.\"\n        );\n      }\n\n      let rootToken = rootObject[\"root\"];\n      if (rootToken == null)\n        throw new Error(\n          \"Root node for ink not found. Are you sure it's a valid .ink.json file?\"\n        );\n\n      let listDefsObj;\n      if ((listDefsObj = rootObject[\"listDefs\"])) {\n        this._listDefinitions =\n          JsonSerialisation.JTokenToListDefinitions(listDefsObj);\n      }\n\n      this._mainContentContainer = asOrThrows(\n        JsonSerialisation.JTokenToRuntimeObject(rootToken),\n        Container\n      );\n\n      this.ResetState();\n    }\n    // ------\n  }\n\n  // Merge together `public string ToJson()` and `void ToJson(SimpleJson.Writer writer)`.\n  // Will only return a value if writer was not provided.\n  public ToJson(writer?: SimpleJson.Writer): string | void {\n    let shouldReturn = false;\n\n    if (!writer) {\n      shouldReturn = true;\n      writer = new SimpleJson.Writer();\n    }\n\n    writer.WriteObjectStart();\n\n    writer.WriteIntProperty(\"inkVersion\", Story.inkVersionCurrent);\n\n    writer.WriteProperty(\"root\", (w) =>\n      JsonSerialisation.WriteRuntimeContainer(w, this._mainContentContainer)\n    );\n\n    if (this._listDefinitions != null) {\n      writer.WritePropertyStart(\"listDefs\");\n      writer.WriteObjectStart();\n\n      for (let def of this._listDefinitions.lists) {\n        writer.WritePropertyStart(def.name);\n        writer.WriteObjectStart();\n\n        for (let [key, value] of def.items) {\n          let item = InkListItem.fromSerializedKey(key);\n          let val = value;\n          writer.WriteIntProperty(item.itemName, val);\n        }\n\n        writer.WriteObjectEnd();\n        writer.WritePropertyEnd();\n      }\n\n      writer.WriteObjectEnd();\n      writer.WritePropertyEnd();\n    }\n\n    writer.WriteObjectEnd();\n\n    if (shouldReturn) return writer.toString();\n  }\n\n  public ResetState() {\n    this.IfAsyncWeCant(\"ResetState\");\n\n    this._state = new StoryState(this);\n    this._state.variablesState.ObserveVariableChange(\n      this.VariableStateDidChangeEvent.bind(this)\n    );\n\n    this.ResetGlobals();\n  }\n\n  public ResetErrors() {\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ResetErrors();\n  }\n\n  public ResetCallstack() {\n    this.IfAsyncWeCant(\"ResetCallstack\");\n    if (this._state === null) {\n      return throwNullException(\"this._state\");\n    }\n    this._state.ForceEnd();\n  }\n\n  public ResetGlobals() {\n    if (this._mainContentContainer.namedContent.get(\"global decl\")) {\n      let originalPointer = this.state.currentPointer.copy();\n\n      this.ChoosePath(new Path(\"global decl\"), false);\n\n      this.ContinueInternal();\n\n      this.state.currentPointer = originalPointer;\n    }\n\n    this.state.variablesState.SnapshotDefaultGlobals();\n  }\n\n  public SwitchFlow(flowName: string) {\n    this.IfAsyncWeCant(\"switch flow\");\n    if (this._asyncSaving) {\n      throw new Error(\n        \"Story is already in background saving mode, can't switch flow to \" +\n          flowName\n      );\n    }\n\n    this.state.SwitchFlow_Internal(flowName);\n  }\n\n  public RemoveFlow(flowName: string) {\n    this.state.RemoveFlow_Internal(flowName);\n  }\n\n  public SwitchToDefaultFlow() {\n    this.state.SwitchToDefaultFlow_Internal();\n  }\n\n  public Continue() {\n    this.ContinueAsync(0);\n    return this.currentText;\n  }\n\n  get canContinue() {\n    return this.state.canContinue;\n  }\n\n  get asyncContinueComplete() {\n    return !this._asyncContinueActive;\n  }\n\n  public ContinueAsync(millisecsLimitAsync: number) {\n    if (!this._hasValidatedExternals) this.ValidateExternalBindings();\n\n    this.ContinueInternal(millisecsLimitAsync);\n  }\n\n  public ContinueInternal(millisecsLimitAsync = 0) {\n    if (this._profiler != null) this._profiler.PreContinue();\n\n    let isAsyncTimeLimited = millisecsLimitAsync > 0;\n    this._recursiveContinueCount++;\n\n    if (!this._asyncContinueActive) {\n      this._asyncContinueActive = isAsyncTimeLimited;\n\n      if (!this.canContinue) {\n        throw new Error(\n          \"Can't continue - should check canContinue before calling Continue\"\n        );\n      }\n\n      this._state.didSafeExit = false;\n      this._state.ResetOutput();\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = true;\n    }\n\n    let durationStopwatch = new Stopwatch();\n    durationStopwatch.Start();\n\n    let outputStreamEndsInNewline = false;\n    this._sawLookaheadUnsafeFunctionAfterNewline = false;\n    do {\n      try {\n        outputStreamEndsInNewline = this.ContinueSingleStep();\n      } catch (e) {\n        if (!(e instanceof StoryException)) throw e;\n\n        this.AddError(e.message, undefined, e.useEndLineNumber);\n        break;\n      }\n\n      if (outputStreamEndsInNewline) break;\n\n      if (\n        this._asyncContinueActive &&\n        durationStopwatch.ElapsedMilliseconds > millisecsLimitAsync\n      ) {\n        break;\n      }\n    } while (this.canContinue);\n\n    durationStopwatch.Stop();\n\n    if (outputStreamEndsInNewline || !this.canContinue) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        this.RestoreStateSnapshot();\n      }\n\n      if (!this.canContinue) {\n        if (this.state.callStack.canPopThread)\n          this.AddError(\n            \"Thread available to pop, threads should always be flat by the end of evaluation?\"\n          );\n\n        if (\n          this.state.generatedChoices.length == 0 &&\n          !this.state.didSafeExit &&\n          this._temporaryEvaluationContainer == null\n        ) {\n          if (this.state.callStack.CanPop(PushPopType.Tunnel))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '->->' to return from a tunnel?\"\n            );\n          else if (this.state.callStack.CanPop(PushPopType.Function))\n            this.AddError(\n              \"unexpectedly reached end of content. Do you need a '~ return'?\"\n            );\n          else if (!this.state.callStack.canPop)\n            this.AddError(\n              \"ran out of content. Do you need a '-> DONE' or '-> END'?\"\n            );\n          else\n            this.AddError(\n              \"unexpectedly reached end of content for unknown reason. Please debug compiler!\"\n            );\n        }\n      }\n\n      this.state.didSafeExit = false;\n      this._sawLookaheadUnsafeFunctionAfterNewline = false;\n\n      if (this._recursiveContinueCount == 1)\n        this._state.variablesState.batchObservingVariableChanges = false;\n\n      this._asyncContinueActive = false;\n      if (this.onDidContinue !== null) this.onDidContinue();\n    }\n\n    this._recursiveContinueCount--;\n\n    if (this._profiler != null) this._profiler.PostContinue();\n\n    // In the following code, we're masking a lot of non-null assertion,\n    // because testing for against `hasError` or `hasWarning` makes sure\n    // the arrays are present and contain at least one element.\n    if (this.state.hasError || this.state.hasWarning) {\n      if (this.onError !== null) {\n        if (this.state.hasError) {\n          for (let err of this.state.currentErrors!) {\n            this.onError(err, ErrorType.Error);\n          }\n        }\n        if (this.state.hasWarning) {\n          for (let err of this.state.currentWarnings!) {\n            this.onError(err, ErrorType.Warning);\n          }\n        }\n        this.ResetErrors();\n      } else {\n        let sb = new StringBuilder();\n        sb.Append(\"Ink had \");\n        if (this.state.hasError) {\n          sb.Append(`${this.state.currentErrors!.length}`);\n          sb.Append(\n            this.state.currentErrors!.length == 1 ? \" error\" : \"errors\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        if (this.state.hasWarning) {\n          sb.Append(`${this.state.currentWarnings!.length}`);\n          sb.Append(\n            this.state.currentWarnings!.length == 1 ? \" warning\" : \"warnings\"\n          );\n          if (this.state.hasWarning) sb.Append(\" and \");\n        }\n        sb.Append(\n          \". It is strongly suggested that you assign an error handler to story.onError. The first issue was: \"\n        );\n        sb.Append(\n          this.state.hasError\n            ? this.state.currentErrors![0]\n            : this.state.currentWarnings![0]\n        );\n\n        throw new StoryException(sb.toString());\n      }\n    }\n  }\n\n  public ContinueSingleStep() {\n    if (this._profiler != null) this._profiler.PreStep();\n\n    this.Step();\n\n    if (this._profiler != null) this._profiler.PostStep();\n\n    if (!this.canContinue && !this.state.callStack.elementIsEvaluateFromGame) {\n      this.TryFollowDefaultInvisibleChoice();\n    }\n\n    if (this._profiler != null) this._profiler.PreSnapshot();\n\n    if (!this.state.inStringEvaluation) {\n      if (this._stateSnapshotAtLastNewline !== null) {\n        if (this._stateSnapshotAtLastNewline.currentTags === null) {\n          return throwNullException(\"this._stateAtLastNewline.currentTags\");\n        }\n        if (this.state.currentTags === null) {\n          return throwNullException(\"this.state.currentTags\");\n        }\n\n        let change = this.CalculateNewlineOutputStateChange(\n          this._stateSnapshotAtLastNewline.currentText,\n          this.state.currentText,\n          this._stateSnapshotAtLastNewline.currentTags.length,\n          this.state.currentTags.length\n        );\n\n        if (\n          change == Story.OutputStateChange.ExtendedBeyondNewline ||\n          this._sawLookaheadUnsafeFunctionAfterNewline\n        ) {\n          this.RestoreStateSnapshot();\n\n          return true;\n        } else if (change == Story.OutputStateChange.NewlineRemoved) {\n          this.DiscardSnapshot();\n        }\n      }\n\n      if (this.state.outputStreamEndsInNewline) {\n        if (this.canContinue) {\n          if (this._stateSnapshotAtLastNewline == null) this.StateSnapshot();\n        } else {\n          this.DiscardSnapshot();\n        }\n      }\n    }\n\n    if (this._profiler != null) this._profiler.PostSnapshot();\n\n    return false;\n  }\n\n  public CalculateNewlineOutputStateChange(\n    prevText: string | null,\n    currText: string | null,\n    prevTagCount: number,\n    currTagCount: number\n  ) {\n    if (prevText === null) {\n      return throwNullException(\"prevText\");\n    }\n    if (currText === null) {\n      return throwNullException(\"currText\");\n    }\n\n    let newlineStillExists =\n      currText.length >= prevText.length &&\n      prevText.length > 0 &&\n      currText.charAt(prevText.length - 1) == \"\\n\";\n    if (\n      prevTagCount == currTagCount &&\n      prevText.length == currText.length &&\n      newlineStillExists\n    )\n      return Story.OutputStateChange.NoChange;\n\n    if (!newlineStillExists) {\n      return Story.OutputStateChange.NewlineRemoved;\n    }\n\n    if (currTagCount > prevTagCount)\n      return Story.OutputStateChange.ExtendedBeyondNewline;\n\n    for (let i = prevText.length; i < currText.length; i++) {\n      let c = currText.charAt(i);\n      if (c != \" \" && c != \"\\t\") {\n        return Story.OutputStateChange.ExtendedBeyondNewline;\n      }\n    }\n\n    return Story.OutputStateChange.NoChange;\n  }\n\n  public ContinueMaximally() {\n    this.IfAsyncWeCant(\"ContinueMaximally\");\n\n    let sb = new StringBuilder();\n\n    while (this.canContinue) {\n      sb.Append(this.Continue());\n    }\n\n    return sb.toString();\n  }\n\n  public ContentAtPath(path: Path) {\n    return this.mainContentContainer.ContentAtPath(path);\n  }\n\n  public KnotContainerWithName(name: string) {\n    let namedContainer = this.mainContentContainer.namedContent.get(name);\n    if (namedContainer instanceof Container) return namedContainer;\n    else return null;\n  }\n\n  public PointerAtPath(path: Path) {\n    if (path.length == 0) return Pointer.Null;\n\n    let p = new Pointer();\n\n    let pathLengthToUse = path.length;\n\n    let result = null;\n    if (path.lastComponent === null) {\n      return throwNullException(\"path.lastComponent\");\n    }\n\n    if (path.lastComponent.isIndex) {\n      pathLengthToUse = path.length - 1;\n      result = this.mainContentContainer.ContentAtPath(\n        path,\n        undefined,\n        pathLengthToUse\n      );\n      p.container = result.container;\n      p.index = path.lastComponent.index;\n    } else {\n      result = this.mainContentContainer.ContentAtPath(path);\n      p.container = result.container;\n      p.index = -1;\n    }\n\n    if (\n      result.obj == null ||\n      (result.obj == this.mainContentContainer && pathLengthToUse > 0)\n    ) {\n      this.Error(\n        \"Failed to find content at path '\" +\n          path +\n          \"', and no approximation of it was possible.\"\n      );\n    } else if (result.approximate)\n      this.Warning(\n        \"Failed to find content at path '\" +\n          path +\n          \"', so it was approximated to: '\" +\n          result.obj.path +\n          \"'.\"\n      );\n\n    return p;\n  }\n\n  public StateSnapshot() {\n    this._stateSnapshotAtLastNewline = this._state;\n    this._state = this._state.CopyAndStartPatching();\n  }\n\n  public RestoreStateSnapshot() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      throwNullException(\"_stateSnapshotAtLastNewline\");\n    }\n    this._stateSnapshotAtLastNewline.RestoreAfterPatch();\n\n    this._state = this._stateSnapshotAtLastNewline;\n    this._stateSnapshotAtLastNewline = null;\n\n    if (!this._asyncSaving) {\n      this._state.ApplyAnyPatch();\n    }\n  }\n\n  public DiscardSnapshot() {\n    if (!this._asyncSaving) this._state.ApplyAnyPatch();\n\n    this._stateSnapshotAtLastNewline = null;\n  }\n\n  public CopyStateForBackgroundThreadSave() {\n    this.IfAsyncWeCant(\"start saving on a background thread\");\n\n    if (this._asyncSaving)\n      throw new Error(\n        \"Story is already in background saving mode, can't call CopyStateForBackgroundThreadSave again!\"\n      );\n\n    let stateToSave = this._state;\n    this._state = this._state.CopyAndStartPatching();\n    this._asyncSaving = true;\n    return stateToSave;\n  }\n\n  public BackgroundSaveComplete() {\n    if (this._stateSnapshotAtLastNewline === null) {\n      this._state.ApplyAnyPatch();\n    }\n\n    this._asyncSaving = false;\n  }\n\n  public Step() {\n    let shouldAddToStream = true;\n\n    let pointer = this.state.currentPointer.copy();\n    if (pointer.isNull) {\n      return;\n    }\n\n    // Container containerToEnter = pointer.Resolve () as Container;\n    let containerToEnter = asOrNull(pointer.Resolve(), Container);\n\n    while (containerToEnter) {\n      this.VisitContainer(containerToEnter, true);\n\n      // No content? the most we can do is step past it\n      if (containerToEnter.content.length == 0) {\n        break;\n      }\n\n      pointer = Pointer.StartOf(containerToEnter);\n      // containerToEnter = pointer.Resolve() as Container;\n      containerToEnter = asOrNull(pointer.Resolve(), Container);\n    }\n\n    this.state.currentPointer = pointer.copy();\n\n    if (this._profiler != null) this._profiler.Step(this.state.callStack);\n\n    // Is the current content object:\n    //  - Normal content\n    //  - Or a logic/flow statement - if so, do it\n    // Stop flow if we hit a stack pop when we're unable to pop (e.g. return/done statement in knot\n    // that was diverted to rather than called as a function)\n    let currentContentObj = pointer.Resolve();\n    let isLogicOrFlowControl =\n      this.PerformLogicAndFlowControl(currentContentObj);\n\n    // Has flow been forced to end by flow control above?\n    if (this.state.currentPointer.isNull) {\n      return;\n    }\n\n    if (isLogicOrFlowControl) {\n      shouldAddToStream = false;\n    }\n\n    // Choice with condition?\n    // var choicePoint = currentContentObj as ChoicePoint;\n    let choicePoint = asOrNull(currentContentObj, ChoicePoint);\n    if (choicePoint) {\n      let choice = this.ProcessChoice(choicePoint);\n      if (choice) {\n        this.state.generatedChoices.push(choice);\n      }\n\n      currentContentObj = null;\n      shouldAddToStream = false;\n    }\n\n    // If the container has no content, then it will be\n    // the \"content\" itself, but we skip over it.\n    if (currentContentObj instanceof Container) {\n      shouldAddToStream = false;\n    }\n\n    // Content to add to evaluation stack or the output stream\n    if (shouldAddToStream) {\n      // If we're pushing a variable pointer onto the evaluation stack, ensure that it's specific\n      // to our current (possibly temporary) context index. And make a copy of the pointer\n      // so that we're not editing the original runtime object.\n      // var varPointer = currentContentObj as VariablePointerValue;\n      let varPointer = asOrNull(currentContentObj, VariablePointerValue);\n      if (varPointer && varPointer.contextIndex == -1) {\n        // Create new object so we're not overwriting the story's own data\n        let contextIdx = this.state.callStack.ContextForVariableNamed(\n          varPointer.variableName\n        );\n        currentContentObj = new VariablePointerValue(\n          varPointer.variableName,\n          contextIdx\n        );\n      }\n\n      // Expression evaluation content\n      if (this.state.inExpressionEvaluation) {\n        this.state.PushEvaluationStack(currentContentObj);\n      }\n      // Output stream content (i.e. not expression evaluation)\n      else {\n        this.state.PushToOutputStream(currentContentObj);\n      }\n    }\n\n    // Increment the content pointer, following diverts if necessary\n    this.NextContent();\n\n    // Starting a thread should be done after the increment to the content pointer,\n    // so that when returning from the thread, it returns to the content after this instruction.\n    // var controlCmd = currentContentObj as ;\n    let controlCmd = asOrNull(currentContentObj, ControlCommand);\n    if (\n      controlCmd &&\n      controlCmd.commandType == ControlCommand.CommandType.StartThread\n    ) {\n      this.state.callStack.PushThread();\n    }\n  }\n\n  public VisitContainer(container: Container, atStart: boolean) {\n    if (!container.countingAtStartOnly || atStart) {\n      if (container.visitsShouldBeCounted)\n        this.state.IncrementVisitCountForContainer(container);\n\n      if (container.turnIndexShouldBeCounted)\n        this.state.RecordTurnIndexVisitToContainer(container);\n    }\n  }\n\n  private _prevContainers: Container[] = [];\n  public VisitChangedContainersDueToDivert() {\n    let previousPointer = this.state.previousPointer.copy();\n    let pointer = this.state.currentPointer.copy();\n\n    if (pointer.isNull || pointer.index == -1) return;\n\n    this._prevContainers.length = 0;\n    if (!previousPointer.isNull) {\n      // Container prevAncestor = previousPointer.Resolve() as Container ?? previousPointer.container as Container;\n      let resolvedPreviousAncestor = previousPointer.Resolve();\n      let prevAncestor =\n        asOrNull(resolvedPreviousAncestor, Container) ||\n        asOrNull(previousPointer.container, Container);\n      while (prevAncestor) {\n        this._prevContainers.push(prevAncestor);\n        // prevAncestor = prevAncestor.parent as Container;\n        prevAncestor = asOrNull(prevAncestor.parent, Container);\n      }\n    }\n\n    let currentChildOfContainer = pointer.Resolve();\n\n    if (currentChildOfContainer == null) return;\n\n    // Container currentContainerAncestor = currentChildOfContainer.parent as Container;\n    let currentContainerAncestor = asOrNull(\n      currentChildOfContainer.parent,\n      Container\n    );\n    let allChildrenEnteredAtStart = true;\n    while (\n      currentContainerAncestor &&\n      (this._prevContainers.indexOf(currentContainerAncestor) < 0 ||\n        currentContainerAncestor.countingAtStartOnly)\n    ) {\n      // Check whether this ancestor container is being entered at the start,\n      // by checking whether the child object is the first.\n      let enteringAtStart =\n        currentContainerAncestor.content.length > 0 &&\n        currentChildOfContainer == currentContainerAncestor.content[0] &&\n        allChildrenEnteredAtStart;\n\n      if (!enteringAtStart) allChildrenEnteredAtStart = false;\n\n      // Mark a visit to this container\n      this.VisitContainer(currentContainerAncestor, enteringAtStart);\n\n      currentChildOfContainer = currentContainerAncestor;\n      // currentContainerAncestor = currentContainerAncestor.parent as Container;\n      currentContainerAncestor = asOrNull(\n        currentContainerAncestor.parent,\n        Container\n      );\n    }\n  }\n\n  public PopChoiceStringAndTags(tags: string[]) {\n    let choiceOnlyStrVal = asOrThrows(\n      this.state.PopEvaluationStack(),\n      StringValue\n    );\n\n    while (\n      this.state.evaluationStack.length > 0 &&\n      asOrNull(this.state.PeekEvaluationStack(), Tag) != null\n    ) {\n      let tag = asOrNull(this.state.PopEvaluationStack(), Tag);\n      if (tag) tags.push(tag.text);\n    }\n    return choiceOnlyStrVal.value;\n  }\n\n  public ProcessChoice(choicePoint: ChoicePoint) {\n    let showChoice = true;\n\n    // Don't create choice if choice point doesn't pass conditional\n    if (choicePoint.hasCondition) {\n      let conditionValue = this.state.PopEvaluationStack();\n      if (!this.IsTruthy(conditionValue)) {\n        showChoice = false;\n      }\n    }\n\n    let startText = \"\";\n    let choiceOnlyText = \"\";\n    let tags: string[] = [];\n\n    if (choicePoint.hasChoiceOnlyContent) {\n      choiceOnlyText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    if (choicePoint.hasStartContent) {\n      startText = this.PopChoiceStringAndTags(tags) || \"\";\n    }\n\n    // Don't create choice if player has already read this content\n    if (choicePoint.onceOnly) {\n      let visitCount = this.state.VisitCountForContainer(\n        choicePoint.choiceTarget\n      );\n      if (visitCount > 0) {\n        showChoice = false;\n      }\n    }\n\n    // We go through the full process of creating the choice above so\n    // that we consume the content for it, since otherwise it'll\n    // be shown on the output stream.\n    if (!showChoice) {\n      return null;\n    }\n\n    let choice = new Choice();\n    choice.targetPath = choicePoint.pathOnChoice;\n    choice.sourcePath = choicePoint.path.toString();\n    choice.isInvisibleDefault = choicePoint.isInvisibleDefault;\n    choice.threadAtGeneration = this.state.callStack.ForkThread();\n    choice.tags = tags.reverse(); //C# is a stack\n    choice.text = (startText + choiceOnlyText).replace(/^[ \\t]+|[ \\t]+$/g, \"\");\n\n    return choice;\n  }\n\n  public IsTruthy(obj: InkObject) {\n    let truthy = false;\n    if (obj instanceof Value) {\n      let val = obj;\n\n      if (val instanceof DivertTargetValue) {\n        let divTarget = val;\n        this.Error(\n          \"Shouldn't use a divert target (to \" +\n            divTarget.targetPath +\n            \") as a conditional value. Did you intend a function call 'likeThis()' or a read count check 'likeThis'? (no arrows)\"\n        );\n        return false;\n      }\n\n      return val.isTruthy;\n    }\n    return truthy;\n  }\n\n  public PerformLogicAndFlowControl(contentObj: InkObject | null) {\n    if (contentObj == null) {\n      return false;\n    }\n\n    // Divert\n    if (contentObj instanceof Divert) {\n      let currentDivert = contentObj;\n\n      if (currentDivert.isConditional) {\n        let conditionValue = this.state.PopEvaluationStack();\n\n        // False conditional? Cancel divert\n        if (!this.IsTruthy(conditionValue)) return true;\n      }\n\n      if (currentDivert.hasVariableTarget) {\n        let varName = currentDivert.variableDivertName;\n\n        let varContents =\n          this.state.variablesState.GetVariableWithName(varName);\n\n        if (varContents == null) {\n          this.Error(\n            \"Tried to divert using a target from a variable that could not be found (\" +\n              varName +\n              \")\"\n          );\n        } else if (!(varContents instanceof DivertTargetValue)) {\n          // var intContent = varContents as IntValue;\n          let intContent = asOrNull(varContents, IntValue);\n\n          let errorMessage =\n            \"Tried to divert to a target from a variable, but the variable (\" +\n            varName +\n            \") didn't contain a divert target, it \";\n          if (intContent instanceof IntValue && intContent.value == 0) {\n            errorMessage += \"was empty/null (the value 0).\";\n          } else {\n            errorMessage += \"contained '\" + varContents + \"'.\";\n          }\n\n          this.Error(errorMessage);\n        }\n\n        let target = asOrThrows(varContents, DivertTargetValue);\n        this.state.divertedPointer = this.PointerAtPath(target.targetPath);\n      } else if (currentDivert.isExternal) {\n        this.CallExternalFunction(\n          currentDivert.targetPathString,\n          currentDivert.externalArgs\n        );\n        return true;\n      } else {\n        this.state.divertedPointer = currentDivert.targetPointer.copy();\n      }\n\n      if (currentDivert.pushesToStack) {\n        this.state.callStack.Push(\n          currentDivert.stackPushType,\n          undefined,\n          this.state.outputStream.length\n        );\n      }\n\n      if (this.state.divertedPointer.isNull && !currentDivert.isExternal) {\n        if (\n          currentDivert &&\n          currentDivert.debugMetadata &&\n          currentDivert.debugMetadata.sourceName != null\n        ) {\n          this.Error(\n            \"Divert target doesn't exist: \" +\n              currentDivert.debugMetadata.sourceName\n          );\n        } else {\n          this.Error(\"Divert resolution failed: \" + currentDivert);\n        }\n      }\n\n      return true;\n    }\n\n    // Start/end an expression evaluation? Or print out the result?\n    else if (contentObj instanceof ControlCommand) {\n      let evalCommand = contentObj;\n\n      switch (evalCommand.commandType) {\n        case ControlCommand.CommandType.EvalStart:\n          this.Assert(\n            this.state.inExpressionEvaluation === false,\n            \"Already in expression evaluation?\"\n          );\n          this.state.inExpressionEvaluation = true;\n          break;\n\n        case ControlCommand.CommandType.EvalEnd:\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Not in expression evaluation mode\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        case ControlCommand.CommandType.EvalOutput:\n          // If the expression turned out to be empty, there may not be anything on the stack\n          if (this.state.evaluationStack.length > 0) {\n            let output = this.state.PopEvaluationStack();\n\n            // Functions may evaluate to Void, in which case we skip output\n            if (!(output instanceof Void)) {\n              // TODO: Should we really always blanket convert to string?\n              // It would be okay to have numbers in the output stream the\n              // only problem is when exporting text for viewing, it skips over numbers etc.\n              let text = new StringValue(output.toString());\n\n              this.state.PushToOutputStream(text);\n            }\n          }\n          break;\n\n        case ControlCommand.CommandType.NoOp:\n          break;\n\n        case ControlCommand.CommandType.Duplicate:\n          this.state.PushEvaluationStack(this.state.PeekEvaluationStack());\n          break;\n\n        case ControlCommand.CommandType.PopEvaluatedValue:\n          this.state.PopEvaluationStack();\n          break;\n\n        case ControlCommand.CommandType.PopFunction:\n        case ControlCommand.CommandType.PopTunnel:\n          let popType =\n            evalCommand.commandType == ControlCommand.CommandType.PopFunction\n              ? PushPopType.Function\n              : PushPopType.Tunnel;\n\n          let overrideTunnelReturnTarget: DivertTargetValue | null = null;\n          if (popType == PushPopType.Tunnel) {\n            let popped = this.state.PopEvaluationStack();\n            // overrideTunnelReturnTarget = popped as DivertTargetValue;\n            overrideTunnelReturnTarget = asOrNull(popped, DivertTargetValue);\n            if (overrideTunnelReturnTarget === null) {\n              this.Assert(\n                popped instanceof Void,\n                \"Expected void if ->-> doesn't override target\"\n              );\n            }\n          }\n\n          if (this.state.TryExitFunctionEvaluationFromGame()) {\n            break;\n          } else if (\n            this.state.callStack.currentElement.type != popType ||\n            !this.state.callStack.canPop\n          ) {\n            let names: Map<PushPopType, string> = new Map();\n            names.set(\n              PushPopType.Function,\n              \"function return statement (~ return)\"\n            );\n            names.set(PushPopType.Tunnel, \"tunnel onwards statement (->->)\");\n\n            let expected = names.get(this.state.callStack.currentElement.type);\n            if (!this.state.callStack.canPop) {\n              expected = \"end of flow (-> END or choice)\";\n            }\n\n            let errorMsg =\n              \"Found \" + names.get(popType) + \", when expected \" + expected;\n\n            this.Error(errorMsg);\n          } else {\n            this.state.PopCallStack();\n\n            if (overrideTunnelReturnTarget)\n              this.state.divertedPointer = this.PointerAtPath(\n                overrideTunnelReturnTarget.targetPath\n              );\n          }\n          break;\n\n        case ControlCommand.CommandType.BeginString:\n          this.state.PushToOutputStream(evalCommand);\n\n          this.Assert(\n            this.state.inExpressionEvaluation === true,\n            \"Expected to be in an expression when evaluating a string\"\n          );\n          this.state.inExpressionEvaluation = false;\n          break;\n\n        // Leave it to story.currentText and story.currentTags to sort out the text from the tags\n        // This is mostly because we can't always rely on the existence of EndTag, and we don't want\n        // to try and flatten dynamic tags to strings every time \\n is pushed to output\n        case ControlCommand.CommandType.BeginTag:\n          this.state.PushToOutputStream(evalCommand);\n          break;\n\n        // EndTag has 2 modes:\n        //  - When in string evaluation (for choices)\n        //  - Normal\n        //\n        // The only way you could have an EndTag in the middle of\n        // string evaluation is if we're currently generating text for a\n        // choice, such as:\n        //\n        //   + choice # tag\n        //\n        // In the above case, the ink will be run twice:\n        //  - First, to generate the choice text. String evaluation\n        //    will be on, and the final string will be pushed to the\n        //    evaluation stack, ready to be popped to make a Choice\n        //    object.\n        //  - Second, when ink generates text after choosing the choice.\n        //    On this ocassion, it's not in string evaluation mode.\n        //\n        // On the writing side, we disallow manually putting tags within\n        // strings like this:\n        //\n        //   {\"hello # world\"}\n        //\n        // So we know that the tag must be being generated as part of\n        // choice content. Therefore, when the tag has been generated,\n        // we push it onto the evaluation stack in the exact same way\n        // as the string for the choice content.\n        case ControlCommand.CommandType.EndTag: {\n          if (this.state.inStringEvaluation) {\n            let contentStackForTag: InkObject[] = [];\n            let outputCountConsumed = 0;\n            for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n              let obj = this.state.outputStream[i];\n              outputCountConsumed++;\n\n              // var command = obj as ControlCommand;\n              let command = asOrNull(obj, ControlCommand);\n              if (command != null) {\n                if (\n                  command.commandType == ControlCommand.CommandType.BeginTag\n                ) {\n                  break;\n                } else {\n                  this.Error(\n                    \"Unexpected ControlCommand while extracting tag from choice\"\n                  );\n                  break;\n                }\n              }\n              if (obj instanceof StringValue) {\n                contentStackForTag.push(obj);\n              }\n            }\n\n            // Consume the content that was produced for this string\n            this.state.PopFromOutputStream(outputCountConsumed);\n            // Build string out of the content we collected\n            let sb = new StringBuilder();\n            for (let strVal of contentStackForTag) {\n              sb.Append(strVal.toString());\n            }\n            let choiceTag = new Tag(\n              this.state.CleanOutputWhitespace(sb.toString())\n            );\n            // Pushing to the evaluation stack means it gets picked up\n            // when a Choice is generated from the next Choice Point.\n            this.state.PushEvaluationStack(choiceTag);\n          } else {\n            // Otherwise! Simply push EndTag, so that in the output stream we\n            // have a structure of: [BeginTag, \"the tag content\", EndTag]\n            this.state.PushToOutputStream(evalCommand);\n          }\n          break;\n        }\n\n        case ControlCommand.CommandType.EndString: {\n          let contentStackForString: InkObject[] = [];\n          let contentToRetain: InkObject[] = [];\n\n          let outputCountConsumed = 0;\n          for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n            let obj = this.state.outputStream[i];\n\n            outputCountConsumed++;\n\n            // var command = obj as ControlCommand;\n            let command = asOrNull(obj, ControlCommand);\n            if (\n              command &&\n              command.commandType == ControlCommand.CommandType.BeginString\n            ) {\n              break;\n            }\n            if (obj instanceof Tag) {\n              contentToRetain.push(obj);\n            }\n            if (obj instanceof StringValue) {\n              contentStackForString.push(obj);\n            }\n          }\n\n          // Consume the content that was produced for this string\n          this.state.PopFromOutputStream(outputCountConsumed);\n\n          // Rescue the tags that we want actually to keep on the output stack\n          // rather than consume as part of the string we're building.\n          // At the time of writing, this only applies to Tag objects generated\n          // by choices, which are pushed to the stack during string generation.\n          for (let rescuedTag of contentToRetain)\n            this.state.PushToOutputStream(rescuedTag);\n\n          // The C# version uses a Stack for contentStackForString, but we're\n          // using a simple array, so we need to reverse it before using it\n          contentStackForString = contentStackForString.reverse();\n\n          // Build string out of the content we collected\n          let sb = new StringBuilder();\n          for (let c of contentStackForString) {\n            sb.Append(c.toString());\n          }\n\n          // Return to expression evaluation (from content mode)\n          this.state.inExpressionEvaluation = true;\n          this.state.PushEvaluationStack(new StringValue(sb.toString()));\n          break;\n        }\n\n        case ControlCommand.CommandType.ChoiceCount:\n          let choiceCount = this.state.generatedChoices.length;\n          this.state.PushEvaluationStack(new IntValue(choiceCount));\n          break;\n\n        case ControlCommand.CommandType.Turns:\n          this.state.PushEvaluationStack(\n            new IntValue(this.state.currentTurnIndex + 1)\n          );\n          break;\n\n        case ControlCommand.CommandType.TurnsSince:\n        case ControlCommand.CommandType.ReadCount:\n          let target = this.state.PopEvaluationStack();\n          if (!(target instanceof DivertTargetValue)) {\n            let extraNote = \"\";\n            if (target instanceof IntValue)\n              extraNote =\n                \". Did you accidentally pass a read count ('knot_name') instead of a target ('-> knot_name')?\";\n            this.Error(\n              \"TURNS_SINCE / READ_COUNT expected a divert target (knot, stitch, label name), but saw \" +\n                target +\n                extraNote\n            );\n            break;\n          }\n\n          // var divertTarget = target as DivertTargetValue;\n          let divertTarget = asOrThrows(target, DivertTargetValue);\n          // var container = ContentAtPath (divertTarget.targetPath).correctObj as Container;\n          let container = asOrNull(\n            this.ContentAtPath(divertTarget.targetPath).correctObj,\n            Container\n          );\n\n          let eitherCount;\n          if (container != null) {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = this.state.TurnsSinceForContainer(container);\n            else eitherCount = this.state.VisitCountForContainer(container);\n          } else {\n            if (\n              evalCommand.commandType == ControlCommand.CommandType.TurnsSince\n            )\n              eitherCount = -1;\n            else eitherCount = 0;\n\n            this.Warning(\n              \"Failed to find container for \" +\n                evalCommand.toString() +\n                \" lookup at \" +\n                divertTarget.targetPath.toString()\n            );\n          }\n\n          this.state.PushEvaluationStack(new IntValue(eitherCount));\n          break;\n\n        case ControlCommand.CommandType.Random: {\n          let maxInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          let minInt = asOrNull(this.state.PopEvaluationStack(), IntValue);\n\n          if (minInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for minimum parameter of RANDOM(min, max)\"\n            );\n\n          if (maxInt == null || minInt instanceof IntValue === false)\n            return this.Error(\n              \"Invalid value for maximum parameter of RANDOM(min, max)\"\n            );\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (maxInt.value === null) {\n            return throwNullException(\"maxInt.value\");\n          }\n          if (minInt.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          // This code is differs a bit from the reference implementation, since\n          // JavaScript has no true integers. Hence integer arithmetics and\n          // interger overflows don't apply here. A loss of precision can\n          // happen with big numbers however.\n          //\n          // The case where 'randomRange' is lower than zero is handled below,\n          // so there's no need to test against Number.MIN_SAFE_INTEGER.\n          let randomRange = maxInt.value - minInt.value + 1;\n          if (!isFinite(randomRange) || randomRange > Number.MAX_SAFE_INTEGER) {\n            randomRange = Number.MAX_SAFE_INTEGER;\n            this.Error(\n              \"RANDOM was called with a range that exceeds the size that ink numbers can use.\"\n            );\n          }\n          if (randomRange <= 0)\n            this.Error(\n              \"RANDOM was called with minimum as \" +\n                minInt.value +\n                \" and maximum as \" +\n                maxInt.value +\n                \". The maximum must be larger\"\n            );\n\n          let resultSeed = this.state.storySeed + this.state.previousRandom;\n          let random = new PRNG(resultSeed);\n\n          let nextRandom = random.next();\n          let chosenValue = (nextRandom % randomRange) + minInt.value;\n          this.state.PushEvaluationStack(new IntValue(chosenValue));\n\n          // Next random number (rather than keeping the Random object around)\n          this.state.previousRandom = nextRandom;\n          break;\n        }\n\n        case ControlCommand.CommandType.SeedRandom:\n          let seed = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          if (seed == null || seed instanceof IntValue === false)\n            return this.Error(\"Invalid value passed to SEED_RANDOM\");\n\n          // Originally a primitive type, but here, can be null.\n          // TODO: Replace by default value?\n          if (seed.value === null) {\n            return throwNullException(\"minInt.value\");\n          }\n\n          this.state.storySeed = seed.value;\n          this.state.previousRandom = 0;\n\n          this.state.PushEvaluationStack(new Void());\n          break;\n\n        case ControlCommand.CommandType.VisitIndex:\n          let count =\n            this.state.VisitCountForContainer(\n              this.state.currentPointer.container\n            ) - 1; // index not count\n          this.state.PushEvaluationStack(new IntValue(count));\n          break;\n\n        case ControlCommand.CommandType.SequenceShuffleIndex:\n          let shuffleIndex = this.NextSequenceShuffleIndex();\n          this.state.PushEvaluationStack(new IntValue(shuffleIndex));\n          break;\n\n        case ControlCommand.CommandType.StartThread:\n          // Handled in main step function\n          break;\n\n        case ControlCommand.CommandType.Done:\n          // We may exist in the context of the initial\n          // act of creating the thread, or in the context of\n          // evaluating the content.\n          if (this.state.callStack.canPopThread) {\n            this.state.callStack.PopThread();\n          }\n\n          // In normal flow - allow safe exit without warning\n          else {\n            this.state.didSafeExit = true;\n\n            // Stop flow in current thread\n            this.state.currentPointer = Pointer.Null;\n          }\n\n          break;\n\n        // Force flow to end completely\n        case ControlCommand.CommandType.End:\n          this.state.ForceEnd();\n          break;\n\n        case ControlCommand.CommandType.ListFromInt:\n          // var intVal = state.PopEvaluationStack () as IntValue;\n          let intVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n          // var listNameVal = state.PopEvaluationStack () as StringValue;\n          let listNameVal = asOrThrows(\n            this.state.PopEvaluationStack(),\n            StringValue\n          );\n\n          if (intVal === null) {\n            throw new StoryException(\n              \"Passed non-integer when creating a list element from a numerical value.\"\n            );\n          }\n\n          let generatedListValue = null;\n\n          if (this.listDefinitions === null) {\n            return throwNullException(\"this.listDefinitions\");\n          }\n          let foundListDef = this.listDefinitions.TryListGetDefinition(\n            listNameVal.value,\n            null\n          );\n          if (foundListDef.exists) {\n            // Originally a primitive type, but here, can be null.\n            // TODO: Replace by default value?\n            if (intVal.value === null) {\n              return throwNullException(\"minInt.value\");\n            }\n\n            let foundItem = foundListDef.result!.TryGetItemWithValue(\n              intVal.value,\n              InkListItem.Null\n            );\n            if (foundItem.exists) {\n              generatedListValue = new ListValue(\n                foundItem.result!,\n                intVal.value\n              );\n            }\n          } else {\n            throw new StoryException(\n              \"Failed to find LIST called \" + listNameVal.value\n            );\n          }\n\n          if (generatedListValue == null) generatedListValue = new ListValue();\n\n          this.state.PushEvaluationStack(generatedListValue);\n          break;\n\n        case ControlCommand.CommandType.ListRange:\n          let max = asOrNull(this.state.PopEvaluationStack(), Value);\n          let min = asOrNull(this.state.PopEvaluationStack(), Value);\n\n          // var targetList = state.PopEvaluationStack () as ListValue;\n          let targetList = asOrNull(this.state.PopEvaluationStack(), ListValue);\n\n          if (targetList === null || min === null || max === null)\n            throw new StoryException(\n              \"Expected list, minimum and maximum for LIST_RANGE\"\n            );\n\n          if (targetList.value === null) {\n            return throwNullException(\"targetList.value\");\n          }\n          let result = targetList.value.ListWithSubRange(\n            min.valueObject,\n            max.valueObject\n          );\n\n          this.state.PushEvaluationStack(new ListValue(result));\n          break;\n\n        case ControlCommand.CommandType.ListRandom: {\n          let listVal = this.state.PopEvaluationStack() as ListValue;\n          if (listVal === null)\n            throw new StoryException(\"Expected list for LIST_RANDOM\");\n\n          let list = listVal.value;\n\n          let newList: InkList | null = null;\n\n          if (list === null) {\n            throw throwNullException(\"list\");\n          }\n          if (list.Count == 0) {\n            newList = new InkList();\n          } else {\n            // Generate a random index for the element to take\n            let resultSeed = this.state.storySeed + this.state.previousRandom;\n            let random = new PRNG(resultSeed);\n\n            let nextRandom = random.next();\n            let listItemIndex = nextRandom % list.Count;\n\n            // This bit is a little different from the original\n            // C# code, since iterators do not work in the same way.\n            // First, we iterate listItemIndex - 1 times, calling next().\n            // The listItemIndex-th time is made outside of the loop,\n            // in order to retrieve the value.\n            let listEnumerator = list.entries();\n            for (let i = 0; i <= listItemIndex - 1; i++) {\n              listEnumerator.next();\n            }\n            let value = listEnumerator.next().value;\n            let randomItem: KeyValuePair<InkListItem, number> = {\n              Key: InkListItem.fromSerializedKey(value[0]),\n              Value: value[1],\n            };\n\n            // Origin list is simply the origin of the one element\n            if (randomItem.Key.originName === null) {\n              return throwNullException(\"randomItem.Key.originName\");\n            }\n            newList = new InkList(randomItem.Key.originName, this);\n            newList.Add(randomItem.Key, randomItem.Value);\n\n            this.state.previousRandom = nextRandom;\n          }\n\n          this.state.PushEvaluationStack(new ListValue(newList));\n          break;\n        }\n\n        default:\n          this.Error(\"unhandled ControlCommand: \" + evalCommand);\n          break;\n      }\n\n      return true;\n    }\n\n    // Variable assignment\n    else if (contentObj instanceof VariableAssignment) {\n      let varAss = contentObj;\n      let assignedVal = this.state.PopEvaluationStack();\n\n      this.state.variablesState.Assign(varAss, assignedVal);\n\n      return true;\n    }\n\n    // Variable reference\n    else if (contentObj instanceof VariableReference) {\n      let varRef = contentObj;\n      let foundValue = null;\n\n      // Explicit read count value\n      if (varRef.pathForCount != null) {\n        let container = varRef.containerForCount;\n        let count = this.state.VisitCountForContainer(container);\n        foundValue = new IntValue(count);\n      }\n\n      // Normal variable reference\n      else {\n        foundValue = this.state.variablesState.GetVariableWithName(varRef.name);\n\n        if (foundValue == null) {\n          this.Warning(\n            \"Variable not found: '\" +\n              varRef.name +\n              \"'. Using default value of 0 (false). This can happen with temporary variables if the declaration hasn't yet been hit. Globals are always given a default value on load if a value doesn't exist in the save state.\"\n          );\n          foundValue = new IntValue(0);\n        }\n      }\n\n      this.state.PushEvaluationStack(foundValue);\n\n      return true;\n    }\n\n    // Native function call\n    else if (contentObj instanceof NativeFunctionCall) {\n      let func = contentObj;\n      let funcParams = this.state.PopEvaluationStack(func.numberOfParameters);\n      let result = func.Call(funcParams);\n      this.state.PushEvaluationStack(result);\n      return true;\n    }\n\n    // No control content, must be ordinary content\n    return false;\n  }\n\n  public ChoosePathString(\n    path: string,\n    resetCallstack = true,\n    args: any[] = []\n  ) {\n    this.IfAsyncWeCant(\"call ChoosePathString right now\");\n    if (this.onChoosePathString !== null) this.onChoosePathString(path, args);\n\n    if (resetCallstack) {\n      this.ResetCallstack();\n    } else {\n      if (this.state.callStack.currentElement.type == PushPopType.Function) {\n        let funcDetail = \"\";\n        let container =\n          this.state.callStack.currentElement.currentPointer.container;\n        if (container != null) {\n          funcDetail = \"(\" + container.path.toString() + \") \";\n        }\n        throw new Error(\n          \"Story was running a function \" +\n            funcDetail +\n            \"when you called ChoosePathString(\" +\n            path +\n            \") - this is almost certainly not not what you want! Full stack trace: \\n\" +\n            this.state.callStack.callStackTrace\n        );\n      }\n    }\n\n    this.state.PassArgumentsToEvaluationStack(args);\n    this.ChoosePath(new Path(path));\n  }\n\n  public IfAsyncWeCant(activityStr: string) {\n    if (this._asyncContinueActive)\n      throw new Error(\n        \"Can't \" +\n          activityStr +\n          \". Story is in the middle of a ContinueAsync(). Make more ContinueAsync() calls or a single Continue() call beforehand.\"\n      );\n  }\n\n  public ChoosePath(p: Path, incrementingTurnIndex: boolean = true) {\n    this.state.SetChosenPath(p, incrementingTurnIndex);\n\n    // Take a note of newly visited containers for read counts etc\n    this.VisitChangedContainersDueToDivert();\n  }\n\n  public ChooseChoiceIndex(choiceIdx: number) {\n    choiceIdx = choiceIdx;\n    let choices = this.currentChoices;\n    this.Assert(\n      choiceIdx >= 0 && choiceIdx < choices.length,\n      \"choice out of range\"\n    );\n\n    let choiceToChoose = choices[choiceIdx];\n    if (this.onMakeChoice !== null) this.onMakeChoice(choiceToChoose);\n\n    if (choiceToChoose.threadAtGeneration === null) {\n      return throwNullException(\"choiceToChoose.threadAtGeneration\");\n    }\n    if (choiceToChoose.targetPath === null) {\n      return throwNullException(\"choiceToChoose.targetPath\");\n    }\n\n    this.state.callStack.currentThread = choiceToChoose.threadAtGeneration;\n\n    this.ChoosePath(choiceToChoose.targetPath);\n  }\n\n  public HasFunction(functionName: string) {\n    try {\n      return this.KnotContainerWithName(functionName) != null;\n    } catch (e) {\n      return false;\n    }\n  }\n\n  public EvaluateFunction(\n    functionName: string,\n    args: any[] = [],\n    returnTextOutput: boolean = false\n  ): Story.EvaluateFunctionTextOutput | any {\n    // EvaluateFunction behaves slightly differently than the C# version.\n    // In C#, you can pass a (second) parameter `out textOutput` to get the\n    // text outputted by the function. This is not possible in js. Instead,\n    // we maintain the regular signature (functionName, args), plus an\n    // optional third parameter returnTextOutput. If set to true, we will\n    // return both the textOutput and the returned value, as an object.\n\n    if (this.onEvaluateFunction !== null)\n      this.onEvaluateFunction(functionName, args);\n\n    this.IfAsyncWeCant(\"evaluate a function\");\n\n    if (functionName == null) {\n      throw new Error(\"Function is null\");\n    } else if (functionName == \"\" || functionName.trim() == \"\") {\n      throw new Error(\"Function is empty or white space.\");\n    }\n\n    let funcContainer = this.KnotContainerWithName(functionName);\n    if (funcContainer == null) {\n      throw new Error(\"Function doesn't exist: '\" + functionName + \"'\");\n    }\n\n    let outputStreamBefore: InkObject[] = [];\n    outputStreamBefore.push(...this.state.outputStream);\n    this._state.ResetOutput();\n\n    this.state.StartFunctionEvaluationFromGame(funcContainer, args);\n\n    // Evaluate the function, and collect the string output\n    let stringOutput = new StringBuilder();\n    while (this.canContinue) {\n      stringOutput.Append(this.Continue());\n    }\n    let textOutput = stringOutput.toString();\n\n    this._state.ResetOutput(outputStreamBefore);\n\n    let result = this.state.CompleteFunctionEvaluationFromGame();\n    if (this.onCompleteEvaluateFunction != null)\n      this.onCompleteEvaluateFunction(functionName, args, textOutput, result);\n\n    return returnTextOutput ? { returned: result, output: textOutput } : result;\n  }\n\n  public EvaluateExpression(exprContainer: Container) {\n    let startCallStackHeight = this.state.callStack.elements.length;\n\n    this.state.callStack.Push(PushPopType.Tunnel);\n\n    this._temporaryEvaluationContainer = exprContainer;\n\n    this.state.GoToStart();\n\n    let evalStackHeight = this.state.evaluationStack.length;\n\n    this.Continue();\n\n    this._temporaryEvaluationContainer = null;\n\n    // Should have fallen off the end of the Container, which should\n    // have auto-popped, but just in case we didn't for some reason,\n    // manually pop to restore the state (including currentPath).\n    if (this.state.callStack.elements.length > startCallStackHeight) {\n      this.state.PopCallStack();\n    }\n\n    let endStackHeight = this.state.evaluationStack.length;\n    if (endStackHeight > evalStackHeight) {\n      return this.state.PopEvaluationStack();\n    } else {\n      return null;\n    }\n  }\n\n  public allowExternalFunctionFallbacks: boolean = false;\n\n  public CallExternalFunction(\n    funcName: string | null,\n    numberOfArguments: number\n  ) {\n    if (funcName === null) {\n      return throwNullException(\"funcName\");\n    }\n    let funcDef = this._externals.get(funcName);\n    let fallbackFunctionContainer = null;\n\n    let foundExternal = typeof funcDef !== \"undefined\";\n\n    if (\n      foundExternal &&\n      !funcDef!.lookAheadSafe &&\n      this._stateSnapshotAtLastNewline !== null\n    ) {\n      this._sawLookaheadUnsafeFunctionAfterNewline = true;\n      return;\n    }\n\n    if (!foundExternal) {\n      if (this.allowExternalFunctionFallbacks) {\n        fallbackFunctionContainer = this.KnotContainerWithName(funcName);\n        this.Assert(\n          fallbackFunctionContainer !== null,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound, and fallback ink function could not be found.\"\n        );\n\n        // Divert direct into fallback function and we're done\n        this.state.callStack.Push(\n          PushPopType.Function,\n          undefined,\n          this.state.outputStream.length\n        );\n        this.state.divertedPointer = Pointer.StartOf(fallbackFunctionContainer);\n        return;\n      } else {\n        this.Assert(\n          false,\n          \"Trying to call EXTERNAL function '\" +\n            funcName +\n            \"' which has not been bound (and ink fallbacks disabled).\"\n        );\n      }\n    }\n\n    // Pop arguments\n    let args: any[] = [];\n    for (let i = 0; i < numberOfArguments; ++i) {\n      // var poppedObj = state.PopEvaluationStack () as Value;\n      let poppedObj = asOrThrows(this.state.PopEvaluationStack(), Value);\n      let valueObj = poppedObj.valueObject;\n      args.push(valueObj);\n    }\n\n    // Reverse arguments from the order they were popped,\n    // so they're the right way round again.\n    args.reverse();\n\n    // Run the function!\n    let funcResult = funcDef!.function(args);\n\n    // Convert return value (if any) to the a type that the ink engine can use\n    let returnObj = null;\n    if (funcResult != null) {\n      returnObj = Value.Create(funcResult);\n      this.Assert(\n        returnObj !== null,\n        \"Could not create ink value from returned object of type \" +\n          typeof funcResult\n      );\n    } else {\n      returnObj = new Void();\n    }\n\n    this.state.PushEvaluationStack(returnObj);\n  }\n\n  public BindExternalFunctionGeneral(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = true\n  ) {\n    this.IfAsyncWeCant(\"bind an external function\");\n    this.Assert(\n      !this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has already been bound.\"\n    );\n    this._externals.set(funcName, {\n      function: func,\n      lookAheadSafe: lookaheadSafe,\n    });\n  }\n\n  public TryCoerce(value: any) {\n    // We're skipping type coercition in this implementation. First of, js\n    // is loosely typed, so it's not that important. Secondly, there is no\n    // clean way (AFAIK) for the user to describe what type of parameters\n    // they expect.\n    return value;\n  }\n\n  public BindExternalFunction(\n    funcName: string,\n    func: Story.ExternalFunction,\n    lookaheadSafe: boolean = false\n  ) {\n    this.Assert(func != null, \"Can't bind a null function\");\n\n    this.BindExternalFunctionGeneral(\n      funcName,\n      (args: any) => {\n        this.Assert(\n          args.length >= func.length,\n          \"External function expected \" + func.length + \" arguments\"\n        );\n\n        let coercedArgs = [];\n        for (let i = 0, l = args.length; i < l; i++) {\n          coercedArgs[i] = this.TryCoerce(args[i]);\n        }\n        return func.apply(null, coercedArgs);\n      },\n      lookaheadSafe\n    );\n  }\n\n  public UnbindExternalFunction(funcName: string) {\n    this.IfAsyncWeCant(\"unbind an external a function\");\n    this.Assert(\n      this._externals.has(funcName),\n      \"Function '\" + funcName + \"' has not been bound.\"\n    );\n    this._externals.delete(funcName);\n  }\n\n  public ValidateExternalBindings(): void;\n  public ValidateExternalBindings(\n    c: Container | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings(\n    o: InkObject | null,\n    missingExternals: Set<string>\n  ): void;\n  public ValidateExternalBindings() {\n    let c: Container | null = null;\n    let o: InkObject | null = null;\n    let missingExternals: Set<string> = arguments[1] || new Set();\n\n    if (arguments[0] instanceof Container) {\n      c = arguments[0];\n    }\n\n    if (arguments[0] instanceof InkObject) {\n      o = arguments[0];\n    }\n\n    if (c === null && o === null) {\n      this.ValidateExternalBindings(\n        this._mainContentContainer,\n        missingExternals\n      );\n      this._hasValidatedExternals = true;\n\n      // No problem! Validation complete\n      if (missingExternals.size == 0) {\n        this._hasValidatedExternals = true;\n      } else {\n        let message = \"Error: Missing function binding for external\";\n        message += missingExternals.size > 1 ? \"s\" : \"\";\n        message += \": '\";\n        message += Array.from(missingExternals).join(\"', '\");\n        message += \"' \";\n        message += this.allowExternalFunctionFallbacks\n          ? \", and no fallback ink function found.\"\n          : \" (ink fallbacks disabled)\";\n\n        this.Error(message);\n      }\n    } else if (c != null) {\n      for (let innerContent of c.content) {\n        let container = innerContent as Container;\n        if (container == null || !container.hasValidName)\n          this.ValidateExternalBindings(innerContent, missingExternals);\n      }\n      for (let [, value] of c.namedContent) {\n        this.ValidateExternalBindings(\n          asOrNull(value, InkObject),\n          missingExternals\n        );\n      }\n    } else if (o != null) {\n      let divert = asOrNull(o, Divert);\n      if (divert && divert.isExternal) {\n        let name = divert.targetPathString;\n        if (name === null) {\n          return throwNullException(\"name\");\n        }\n        if (!this._externals.has(name)) {\n          if (this.allowExternalFunctionFallbacks) {\n            let fallbackFound =\n              this.mainContentContainer.namedContent.has(name);\n            if (!fallbackFound) {\n              missingExternals.add(name);\n            }\n          } else {\n            missingExternals.add(name);\n          }\n        }\n      }\n    }\n  }\n\n  public ObserveVariable(\n    variableName: string,\n    observer: Story.VariableObserver\n  ) {\n    this.IfAsyncWeCant(\"observe a new variable\");\n\n    if (this._variableObservers === null) this._variableObservers = new Map();\n\n    if (!this.state.variablesState.GlobalVariableExistsWithName(variableName))\n      throw new Error(\n        \"Cannot observe variable '\" +\n          variableName +\n          \"' because it wasn't declared in the ink story.\"\n      );\n\n    if (this._variableObservers.has(variableName)) {\n      this._variableObservers.get(variableName)!.push(observer);\n    } else {\n      this._variableObservers.set(variableName, [observer]);\n    }\n  }\n\n  public ObserveVariables(\n    variableNames: string[],\n    observers: Story.VariableObserver[]\n  ) {\n    for (let i = 0, l = variableNames.length; i < l; i++) {\n      this.ObserveVariable(variableNames[i], observers[i]);\n    }\n  }\n\n  public RemoveVariableObserver(\n    observer?: Story.VariableObserver,\n    specificVariableName?: string\n  ) {\n    // A couple of things to know about this method:\n    //\n    // 1. Since `RemoveVariableObserver` is exposed to the JavaScript world,\n    //    optionality is marked as `undefined` rather than `null`.\n    //    To keep things simple, null-checks are performed using regular\n    //    equality operators, where undefined == null.\n    //\n    // 2. Since C# delegates are translated to arrays of functions,\n    //    -= becomes a call to splice and null-checks are replaced by\n    //    emptiness-checks.\n    //\n    this.IfAsyncWeCant(\"remove a variable observer\");\n\n    if (this._variableObservers === null) return;\n\n    if (specificVariableName != null) {\n      if (this._variableObservers.has(specificVariableName)) {\n        if (observer != null) {\n          let variableObservers =\n            this._variableObservers.get(specificVariableName);\n          if (variableObservers != null) {\n            variableObservers.splice(variableObservers.indexOf(observer), 1);\n            if (variableObservers.length === 0) {\n              this._variableObservers.delete(specificVariableName);\n            }\n          }\n        } else {\n          this._variableObservers.delete(specificVariableName);\n        }\n      }\n    } else if (observer != null) {\n      let keys = this._variableObservers.keys();\n      for (let varName of keys) {\n        let variableObservers = this._variableObservers.get(varName);\n        if (variableObservers != null) {\n          variableObservers.splice(variableObservers.indexOf(observer), 1);\n          if (variableObservers.length === 0) {\n            this._variableObservers.delete(varName);\n          }\n        }\n      }\n    }\n  }\n\n  public VariableStateDidChangeEvent(\n    variableName: string,\n    newValueObj: InkObject\n  ) {\n    if (this._variableObservers === null) return;\n\n    let observers = this._variableObservers.get(variableName);\n    if (typeof observers !== \"undefined\") {\n      if (!(newValueObj instanceof Value)) {\n        throw new Error(\n          \"Tried to get the value of a variable that isn't a standard type\"\n        );\n      }\n      // var val = newValueObj as Value;\n      let val = asOrThrows(newValueObj, Value);\n\n      for (let observer of observers) {\n        observer(variableName, val.valueObject);\n      }\n    }\n  }\n\n  get globalTags() {\n    return this.TagsAtStartOfFlowContainerWithPathString(\"\");\n  }\n\n  public TagsForContentAtPath(path: string) {\n    return this.TagsAtStartOfFlowContainerWithPathString(path);\n  }\n\n  public TagsAtStartOfFlowContainerWithPathString(pathString: string) {\n    let path = new Path(pathString);\n\n    let flowContainer = this.ContentAtPath(path).container;\n    if (flowContainer === null) {\n      return throwNullException(\"flowContainer\");\n    }\n    while (true) {\n      let firstContent: InkObject = flowContainer.content[0];\n      if (firstContent instanceof Container) flowContainer = firstContent;\n      else break;\n    }\n\n    let inTag = false;\n    let tags: string[] | null = null;\n\n    for (let c of flowContainer.content) {\n      // var tag = c as Runtime.Tag;\n      let command = asOrNull(c, ControlCommand);\n\n      if (command != null) {\n        if (command.commandType == ControlCommand.CommandType.BeginTag) {\n          inTag = true;\n        } else if (command.commandType == ControlCommand.CommandType.EndTag) {\n          inTag = false;\n        }\n      } else if (inTag) {\n        let str = asOrNull(c, StringValue);\n        if (str !== null) {\n          if (tags === null) tags = [];\n          if (str.value !== null) tags.push(str.value);\n        } else {\n          this.Error(\n            \"Tag contained non-text content. Only plain text is allowed when using globalTags or TagsAtContentPath. If you want to evaluate dynamic content, you need to use story.Continue().\"\n          );\n        }\n      } else {\n        break;\n      }\n    }\n\n    return tags;\n  }\n\n  public BuildStringOfHierarchy() {\n    let sb = new StringBuilder();\n\n    this.mainContentContainer.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n\n    return sb.toString();\n  }\n\n  public BuildStringOfContainer(container: Container) {\n    let sb = new StringBuilder();\n    container.BuildStringOfHierarchy(\n      sb,\n      0,\n      this.state.currentPointer.Resolve()\n    );\n    return sb.toString();\n  }\n\n  public NextContent() {\n    this.state.previousPointer = this.state.currentPointer.copy();\n\n    if (!this.state.divertedPointer.isNull) {\n      this.state.currentPointer = this.state.divertedPointer.copy();\n      this.state.divertedPointer = Pointer.Null;\n\n      this.VisitChangedContainersDueToDivert();\n\n      if (!this.state.currentPointer.isNull) {\n        return;\n      }\n    }\n\n    let successfulPointerIncrement = this.IncrementContentPointer();\n\n    if (!successfulPointerIncrement) {\n      let didPop = false;\n\n      if (this.state.callStack.CanPop(PushPopType.Function)) {\n        this.state.PopCallStack(PushPopType.Function);\n\n        if (this.state.inExpressionEvaluation) {\n          this.state.PushEvaluationStack(new Void());\n        }\n\n        didPop = true;\n      } else if (this.state.callStack.canPopThread) {\n        this.state.callStack.PopThread();\n\n        didPop = true;\n      } else {\n        this.state.TryExitFunctionEvaluationFromGame();\n      }\n\n      if (didPop && !this.state.currentPointer.isNull) {\n        this.NextContent();\n      }\n    }\n  }\n\n  public IncrementContentPointer() {\n    let successfulIncrement = true;\n\n    let pointer = this.state.callStack.currentElement.currentPointer.copy();\n    pointer.index++;\n\n    if (pointer.container === null) {\n      return throwNullException(\"pointer.container\");\n    }\n    while (pointer.index >= pointer.container.content.length) {\n      successfulIncrement = false;\n\n      // Container nextAncestor = pointer.container.parent as Container;\n      let nextAncestor = asOrNull(pointer.container.parent, Container);\n      if (nextAncestor instanceof Container === false) {\n        break;\n      }\n\n      let indexInAncestor = nextAncestor!.content.indexOf(pointer.container);\n      if (indexInAncestor == -1) {\n        break;\n      }\n\n      pointer = new Pointer(nextAncestor, indexInAncestor);\n\n      pointer.index++;\n\n      successfulIncrement = true;\n      if (pointer.container === null) {\n        return throwNullException(\"pointer.container\");\n      }\n    }\n\n    if (!successfulIncrement) pointer = Pointer.Null;\n\n    this.state.callStack.currentElement.currentPointer = pointer.copy();\n\n    return successfulIncrement;\n  }\n\n  public TryFollowDefaultInvisibleChoice() {\n    let allChoices = this._state.currentChoices;\n\n    let invisibleChoices = allChoices.filter((c) => c.isInvisibleDefault);\n\n    if (\n      invisibleChoices.length == 0 ||\n      allChoices.length > invisibleChoices.length\n    )\n      return false;\n\n    let choice = invisibleChoices[0];\n\n    if (choice.targetPath === null) {\n      return throwNullException(\"choice.targetPath\");\n    }\n\n    if (choice.threadAtGeneration === null) {\n      return throwNullException(\"choice.threadAtGeneration\");\n    }\n\n    this.state.callStack.currentThread = choice.threadAtGeneration;\n\n    if (this._stateSnapshotAtLastNewline !== null) {\n      this.state.callStack.currentThread = this.state.callStack.ForkThread();\n    }\n\n    this.ChoosePath(choice.targetPath, false);\n\n    return true;\n  }\n\n  public NextSequenceShuffleIndex() {\n    // var numElementsIntVal = state.PopEvaluationStack () as IntValue;\n    let numElementsIntVal = asOrNull(this.state.PopEvaluationStack(), IntValue);\n    if (!(numElementsIntVal instanceof IntValue)) {\n      this.Error(\"expected number of elements in sequence for shuffle index\");\n      return 0;\n    }\n\n    let seqContainer = this.state.currentPointer.container;\n    if (seqContainer === null) {\n      return throwNullException(\"seqContainer\");\n    }\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (numElementsIntVal.value === null) {\n      return throwNullException(\"numElementsIntVal.value\");\n    }\n    let numElements = numElementsIntVal.value;\n\n    // var seqCountVal = state.PopEvaluationStack () as IntValue;\n    let seqCountVal = asOrThrows(this.state.PopEvaluationStack(), IntValue);\n    let seqCount = seqCountVal.value;\n\n    // Originally a primitive type, but here, can be null.\n    // TODO: Replace by default value?\n    if (seqCount === null) {\n      return throwNullException(\"seqCount\");\n    }\n\n    let loopIndex = seqCount / numElements;\n    let iterationIndex = seqCount % numElements;\n\n    let seqPathStr = seqContainer.path.toString();\n    let sequenceHash = 0;\n    for (let i = 0, l = seqPathStr.length; i < l; i++) {\n      sequenceHash += seqPathStr.charCodeAt(i) || 0;\n    }\n    let randomSeed = sequenceHash + loopIndex + this.state.storySeed;\n    let random = new PRNG(Math.floor(randomSeed));\n\n    let unpickedIndices = [];\n    for (let i = 0; i < numElements; ++i) {\n      unpickedIndices.push(i);\n    }\n\n    for (let i = 0; i <= iterationIndex; ++i) {\n      let chosen = random.next() % unpickedIndices.length;\n      let chosenIndex = unpickedIndices[chosen];\n      unpickedIndices.splice(chosen, 1);\n\n      if (i == iterationIndex) {\n        return chosenIndex;\n      }\n    }\n\n    throw new Error(\"Should never reach here\");\n  }\n\n  public Error(message: string, useEndLineNumber = false): never {\n    let e = new StoryException(message);\n    e.useEndLineNumber = useEndLineNumber;\n    throw e;\n  }\n\n  public Warning(message: string) {\n    this.AddError(message, true);\n  }\n\n  public AddError(\n    message: string,\n    isWarning = false,\n    useEndLineNumber = false\n  ) {\n    let dm = this.currentDebugMetadata;\n\n    let errorTypeStr = isWarning ? \"WARNING\" : \"ERROR\";\n\n    if (dm != null) {\n      let lineNum = useEndLineNumber ? dm.endLineNumber : dm.startLineNumber;\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": '\" +\n        dm.fileName +\n        \"' line \" +\n        lineNum +\n        \": \" +\n        message;\n    } else if (!this.state.currentPointer.isNull) {\n      message =\n        \"RUNTIME \" +\n        errorTypeStr +\n        \": (\" +\n        this.state.currentPointer +\n        \"): \" +\n        message;\n    } else {\n      message = \"RUNTIME \" + errorTypeStr + \": \" + message;\n    }\n\n    this.state.AddError(message, isWarning);\n\n    // In a broken state don't need to know about any other errors.\n    if (!isWarning) this.state.ForceEnd();\n  }\n\n  public Assert(condition: boolean, message: string | null = null) {\n    if (condition == false) {\n      if (message == null) {\n        message = \"Story assert\";\n      }\n\n      throw new Error(message + \" \" + this.currentDebugMetadata);\n    }\n  }\n\n  get currentDebugMetadata(): DebugMetadata | null {\n    let dm: DebugMetadata | null;\n\n    let pointer = this.state.currentPointer;\n    if (!pointer.isNull && pointer.Resolve() !== null) {\n      dm = pointer.Resolve()!.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    for (let i = this.state.callStack.elements.length - 1; i >= 0; --i) {\n      pointer = this.state.callStack.elements[i].currentPointer;\n      if (!pointer.isNull && pointer.Resolve() !== null) {\n        dm = pointer.Resolve()!.debugMetadata;\n        if (dm !== null) {\n          return dm;\n        }\n      }\n    }\n\n    for (let i = this.state.outputStream.length - 1; i >= 0; --i) {\n      let outputObj = this.state.outputStream[i];\n      dm = outputObj.debugMetadata;\n      if (dm !== null) {\n        return dm;\n      }\n    }\n\n    return null;\n  }\n\n  get mainContentContainer() {\n    if (this._temporaryEvaluationContainer) {\n      return this._temporaryEvaluationContainer;\n    } else {\n      return this._mainContentContainer;\n    }\n  }\n\n  /**\n   * `_mainContentContainer` is almost guaranteed to be set in the\n   * constructor, unless the json is malformed.\n   */\n  private _mainContentContainer!: Container;\n  private _listDefinitions: ListDefinitionsOrigin | null = null;\n\n  private _externals: Map<string, Story.ExternalFunctionDef>;\n  private _variableObservers: Map<string, Story.VariableObserver[]> | null =\n    null;\n  private _hasValidatedExternals: boolean = false;\n\n  private _temporaryEvaluationContainer: Container | null = null;\n\n  /**\n   * `state` is almost guaranteed to be set in the constructor, unless\n   * using the compiler-specific constructor which will likely not be used in\n   * the real world.\n   */\n  private _state!: StoryState;\n\n  private _asyncContinueActive: boolean = false;\n  private _stateSnapshotAtLastNewline: StoryState | null = null;\n  private _sawLookaheadUnsafeFunctionAfterNewline: boolean = false;\n\n  private _recursiveContinueCount: number = 0;\n\n  private _asyncSaving: boolean = false;\n\n  private _profiler: any | null = null; // TODO: Profiler\n}\n\nexport namespace Story {\n  export enum OutputStateChange {\n    NoChange = 0,\n    ExtendedBeyondNewline = 1,\n    NewlineRemoved = 2,\n  }\n\n  export interface EvaluateFunctionTextOutput {\n    returned: any;\n    output: string;\n  }\n\n  export interface ExternalFunctionDef {\n    function: ExternalFunction;\n    lookAheadSafe: boolean;\n  }\n\n  export type VariableObserver = (variableName: string, newValue: any) => void;\n  export type ExternalFunction = (...args: any) => any;\n}\n"],"names":["Path","constructor","this","_components","_componentsString","_isRelative","arguments","componentsString","Component","head","tail","push","concat","Array","relative","isRelative","componentCount","length","tailComps","slice","self","lastComponent","lastComponentIdx","containsNamedComponent","i","l","isIndex","path","GetComponent","index","PathByAppendingPath","pathToAppend","p","upwardMoves","isParent","join","value","substring","componentStrings","split","str","test","parseInt","toString","Equals","otherPath","PathByAppendingComponent","c","Debug","ValueType","PushPopType","ErrorType","asOrNull","obj","type","unsafeTypeAssertion","asOrThrows","Error","asINamedContentOrNull","hasValidName","name","nullIfUndefined","isEquatable","parentId","indexOrName","ToParent","otherComp","Assert","condition","message","console","warn","trace","AssertType","variable","NullException","throwNullException","InkObject","parent","_debugMetadata","_path","debugMetadata","ownDebugMetadata","DebugLineNumberOfPath","root","rootContentContainer","targetContent","ContentAtPath","dm","startLineNumber","comps","child","container","Container","namedChild","unshift","content","indexOf","ResolvePath","nearestContainer","contentContainer","ConvertPathToRelative","globalPath","ownPath","minPathLength","Math","min","lastSharedPathCompIndex","ownComp","numUpwardsMoves","newPathComps","up","down","CompactPathString","globalPathStr","relativePathStr","ancestor","Copy","SetChild","prop","StringBuilder","string","Length","Append","AppendLine","AppendFormat","format","args","replace","match","num","Clear","InkListItem","originName","itemName","nameParts","Null","isNull","fullName","otherItem","copy","serialized","JSON","stringify","fromSerializedKey","key","parse","isLikeInkListItem","inkListItem","item","hasOwnProperty","InkList","Map","super","origins","_originNames","otherList","otherOriginNames","originNames","singleOriginListName","originStory","SetInitialOriginName","listDefinitions","def","TryListGetDefinition","exists","result","singleElement","Add","Key","Value","FromString","myListItem","listValue","_a","FindSingleItemListWithName","AddItem","itemOrItemName","origin","intVal","TryGetValueForItem","foundListDef","ContainsItemWithName","itemVal","ValueForItem","ContainsItemNamed","ContainsKey","has","serializedKey","set","Remove","delete","Count","size","originOfMaxItem","maxOriginName","maxItem","every","initialOriginName","SetInitialOriginNames","initialOriginNames","max","minItem","inverse","list","items","all","Union","union","Intersect","intersection","HasIntersection","Without","listToRemove","Contains","what","GreaterThan","GreaterThanOrEquals","LessThan","LessThanOrEquals","MaxAsList","MinAsList","ListWithSubRange","minBound","maxBound","ordered","orderedItems","minValue","maxValue","Number","MAX_SAFE_INTEGER","isInteger","subList","otherInkList","sort","x","y","localeCompare","sb","valueOf","NaN","StoryException","useEndLineNumber","tryGetValueFromMap","map","val","get","AbstractValue","Create","preferredNumberType","Int","IntValue","Float","isNaN","FloatValue","BoolValue","Boolean","StringValue","String","DivertTargetValue","ListValue","valueObject","BadCastException","targetType","valueType","isTruthy","Bool","Cast","newType","_isNewline","_isInlineWhitespace","isNewline","isInlineWhitespace","isNonWhitespace","parsedInt","defaultValue","tryParseInt","parsedFloat","parseFloat","tryParseFloat","targetPath","DivertTarget","VariablePointerValue","variableName","contextIndex","_contextIndex","VariablePointer","List","listOrSingleItem","singleValue","RetainListOriginsForAssignment","oldValue","newValue","oldList","newList","SearchResult","approximate","correctObj","searchResult","_content","namedContent","visitsShouldBeCounted","turnIndexShouldBeCounted","countingAtStartOnly","_pathToFirstLeafContent","AddContent","namedOnlyContent","namedOnlyContentDict","inkObject","named","existingNamedOnly","AddToNamedContentOnly","countFlags","flags","CountFlags","Visits","Turns","CountStartOnly","flag","pathToFirstLeafContent","internalPathToFirstLeafContent","components","contentObjOrList","contentList","contentObj","TryAddNamedContent","namedContentObj","partialPathStart","partialPathLength","currentContainer","currentObj","comp","foundObj","ContentWithPathComponent","InsertContent","splice","AddContentsOfContainer","otherContainer","component","foundContent","BuildStringOfHierarchy","indentation","pointedObj","appendIndentation","onlyNamed","Glue","ControlCommand","commandType","CommandType","NotSet","_commandType","EvalStart","EvalOutput","EvalEnd","Duplicate","PopEvaluatedValue","PopFunction","PopTunnel","BeginString","EndString","NoOp","ChoiceCount","TurnsSince","ReadCount","Random","SeedRandom","VisitIndex","SequenceShuffleIndex","StartThread","Done","End","ListFromInt","ListRange","ListRandom","BeginTag","EndTag","Pointer","Resolve","StartOf","Divert","stackPushType","_targetPath","_targetPointer","variableDivertName","pushesToStack","isExternal","externalArgs","isConditional","targetObj","targetPointer","targetPathString","hasVariableTarget","otherDivert","targetStr","Function","ChoicePoint","onceOnly","_pathOnChoice","hasCondition","hasStartContent","hasChoiceOnlyContent","isInvisibleDefault","pathOnChoice","choiceTargetObj","choiceTarget","pathStringOnChoice","VariableReference","pathForCount","containerForCount","pathStringForCount","VariableAssignment","isNewDeclaration","isGlobal","Void","NativeFunctionCall","_name","_numberOfParameters","_prototype","_isPrototype","_operationFuncs","GenerateNativeFunctionsIfNecessary","numberOfParameters","CallWithName","functionName","CallExistsWithName","_nativeFunctions","Call","parameters","hasList","CallBinaryListOperation","coercedParams","CoerceValuesToSingleType","coercedType","CallType","parametersOfSingleType","param1","valType","val1","paramCount","opForTypeObj","val2","opForType","resultVal","CallListIncrementOperation","v1","v2","op","asBooleanOrThrows","listIntParams","listVal","resultInkList","listItemKey","listItemValue","listItem","intOp","targetInt","itemOrigin","incrementedItem","TryGetItemWithValue","parametersIn","specialCaseList","parametersOut","inkObjectVal","castedValue","Identity","t","AddIntBinaryOp","Subtract","Multiply","Divide","floor","Mod","AddIntUnaryOp","Negate","Equal","Greater","Less","NotEquals","Not","And","Or","Max","Min","Pow","pow","Floor","Ceiling","AddFloatBinaryOp","AddFloatUnaryOp","ceil","AddStringBinaryOp","Has","includes","Hasnt","AddListBinaryOp","AddListUnaryOp","Invert","All","ListMin","ListMax","ValueOfList","divertTargetsEqual","d1","d2","divertTargetsNotEqual","AddOpToNativeFunc","AddOpFuncForType","nativeFunc","Tag","tagText","text","Choice","threadAtGeneration","sourcePath","tags","originalThreadIndex","ListDefinition","_items","_itemNameToValues","ContainsItem","ListDefinitionsOrigin","lists","_lists","_allUnambiguousListValueCache","listOfLists","definition","JsonSerialisation","JArrayToRuntimeObjList","jArray","skipLast","count","jTok","runtimeObj","JTokenToRuntimeObject","WriteDictionaryRuntimeObjs","writer","dictionary","WriteObjectStart","WritePropertyStart","WriteRuntimeObject","WritePropertyEnd","WriteObjectEnd","WriteListRuntimeObjs","WriteArrayStart","WriteArrayEnd","WriteIntDictionary","dict","WriteIntProperty","WriteRuntimeContainer","divert","divTypeKey","Tunnel","WriteProperty","choicePoint","boolVal","WriteBool","WriteInt","floatVal","WriteFloat","strVal","Write","WriteStringStart","WriteStringInner","WriteStringEnd","WriteInkList","divTargetVal","varPtrVal","controlCmd","_controlCommandNames","varRef","readCountPath","varAss","tag","choice","WriteChoice","JObjectToDictionaryRuntimeObjs","jObject","JObjectToIntDictionary","token","firstChar","isArray","propValue","varPtr","isDivert","divPushType","external","target","readCountVarRef","isVarAss","isGlobalVar","varName","isNewDecl","undefined","listContent","rawList","namesAsObjs","nameToVal","JObjectToChoice","JArrayToContainer","toJson","me","removes","space","k","v","some","r","withoutName","hasNameProperty","hasTerminator","namedContainer","WriteNull","terminatingObj","namedContentItem","namedSubContainer","jObj","WritePropertyNameStart","WritePropertyNameInner","WritePropertyNameEnd","ListDefinitionsToJToken","listDefJson","JTokenToListDefinitions","defsObj","allDefs","nameValueKey","nameValue","TOTAL_VALUES","CallStack","_threadCounter","_startOfRoot","Story","storyContext","Reset","toCopy","_threads","otherThread","elements","callStack","depth","currentElement","cs","callstack","currentElementIndex","currentThread","canPop","Thread","Element","SetJsonToken","jThreads","jThreadTok","jThreadObj","thread","WriteJson","w","WriteObject","PushThread","newThread","threadIndex","ForkThread","forkedThread","PopThread","canPopThread","elementIsEvaluateFromGame","FunctionEvaluationFromGame","Push","externalEvaluationStackHeight","outputStreamLengthWithPushed","element","currentPointer","evaluationStackHeightWhenPushed","functionStartInOutputStream","CanPop","Pop","pop","GetTemporaryVariableWithName","varValue","temporaryVariables","SetTemporaryVariable","declareNew","contextElement","ContextForVariableNamed","ThreadWithIndex","filtered","filter","callStackTrace","isCurrent","pointer","inExpressionEvaluation","previousPointer","jThreadCallstack","jElTok","currentContainerPathStr","jElementObj","pushPopType","currentContainerPathStrToken","threadPointerResult","Warning","el","temps","clear","prevContentObjPath","prevPath","PointerAtPath","e","resolvedPointer","VariablesState","listDefsOrigin","variableChangedEventCallbacks","patch","_batchObservingVariableChanges","_defaultGlobalVariables","_changedVariablesForBatchObs","Set","_globalVariables","_callStack","_listDefsOrigin","Proxy","$","variableChangedEvent","callback","batchObservingVariableChanges","currentValue","varContents","TryGetGlobal","SetGlobal","ApplyPatch","namedVarKey","namedVarValue","globals","changedVariables","add","jToken","varValKey","varValValue","loadedToken","tokenInkObject","keyValKey","keyValValue","dontSaveDefaultValues","defaultVal","RuntimeObjectsEqual","obj1","obj2","GetVariableWithName","GetRawVariableWithName","varPointer","ValueAtVariablePointer","TryGetDefaultVariableValue","GlobalVariableExistsWithName","variableValue","Assign","setGlobal","ResolveVariablePointer","existingPointer","SnapshotDefaultGlobals","AddChangedVariable","GetContextIndexOfVariableNamed","doubleRedirectionPointer","ObserveVariableChange","PRNG","seed","next","nextFloat","StatePatch","_changedVariables","_visitCounts","_turnIndices","_globals","visitCounts","turnIndices","TryGetVisitCount","SetVisitCount","SetTurnIndex","TryGetTurnIndex","SimpleJson","TextToDictionary","Reader","ToDictionary","TextToArray","ToArray","_rootObject","Writer","_currentPropertyName","_currentString","_stateStack","_collectionStack","_propertyNameStack","_jsonObject","inner","StartNewObject","newObject","state","State","Property","currentCollection","currentPropertyName","propertyName","None","StateElement","Object","innerOrContent","WriteFloatProperty","IncrementChildCount","childCount","PropertyName","escape","_addToCurrentObject","error","POSITIVE_INFINITY","NEGATIVE_INFINITY","currEl","Flow","story","outputStream","currentChoices","jChoiceThreadsObj","LoadFlowChoiceThreads","hasChoiceThreads","jChoiceThreads","foundActiveThread","jSavedChoiceThread","StoryState","kInkSaveStateVersion","kMinCompatibleLoadVersion","onDidLoadState","_currentErrors","_currentWarnings","divertedPointer","_currentTurnIndex","storySeed","previousRandom","didSafeExit","_currentText","_currentTags","_outputStreamTextDirty","_outputStreamTagsDirty","_patch","_aliveFlowNames","_namedFlows","kDefaultFlowName","_aliveFlowNamesDirty","_currentFlow","OutputStreamDirty","_evaluationStack","_variablesState","currentTurnIndex","timeSeed","Date","getTime","GoToStart","ToJson","indented","LoadJson","json","LoadJsonObj","VisitCountAtPathString","pathString","visitCountOut","VisitCountForContainer","containerPathStr","count2","IncrementVisitCountForContainer","currCount","RecordTurnIndexVisitToContainer","TurnsSinceForContainer","index2","callstackDepth","canContinue","generatedChoices","currentErrors","currentWarnings","variablesState","evaluationStack","currentPathString","hasError","hasWarning","currentText","inTag","outputObj","textContent","controlCommand","CleanOutputWhitespace","currentWhitespaceStart","startOfLine","charAt","currentTags","txt","currentFlowName","currentFlowIsDefaultFlow","aliveFlowNames","flowName","keys","mainContentContainer","SwitchFlow_Internal","flow","SwitchToDefaultFlow_Internal","RemoveFlow_Internal","CopyAndStartPatching","namedFlowKey","namedFlowValue","RestoreAfterPatch","ApplyAnyPatch","ApplyCountChanges","newCount","isVisit","inkVersionCurrent","jSaveVersion","flowsObj","flowsObjDict","flowsObjDictEntries","entries","namedFlowObjKey","namedFlowObjValue","flowObj","currFlowName","currentDivertTargetPath","divertPath","ResetErrors","ResetOutput","objs","PushToOutputStream","listText","TrySplittingHeadTailWhitespace","textObj","PushToOutputStreamIndividual","PopFromOutputStream","single","headFirstNewlineIdx","headLastNewlineIdx","tailLastNewlineIdx","tailFirstNewlineIdx","listTexts","innerStrStart","innerStrEnd","leadingSpaces","innerStrText","numSpaces","trailingSpaces","glue","includeInOutput","TrimNewlinesFromOutputStream","functionTrimIndex","glueTrimIndex","o","trimIndex","RemoveExistingGlue","callStackElements","outputStreamEndsInNewline","outputStreamContainsContent","removeWhitespaceFrom","cmd","inStringEvaluation","PushEvaluationStack","n","PopEvaluationStack","numberOfObjects","PeekEvaluationStack","ForceEnd","TrimWhitespaceFromFunctionEnd","functionStartPoint","PopCallStack","popType","SetChosenPath","incrementingTurnIndex","newPointer","StartFunctionEvaluationFromGame","funcContainer","PassArgumentsToEvaluationStack","TryExitFunctionEvaluationFromGame","CompleteFunctionEvaluationFromGame","originalEvaluationStackHeight","returnedObj","poppedObj","returnVal","AddError","isWarning","Stopwatch","startTime","ElapsedMilliseconds","Start","Stop","nVal","isFinite","inkVersionMinimumCompatible","onError","onDidContinue","onMakeChoice","onEvaluateFunction","onCompleteEvaluateFunction","onChoosePathString","_prevContainers","allowExternalFunctionFallbacks","_listDefinitions","_variableObservers","_hasValidatedExternals","_temporaryEvaluationContainer","_asyncContinueActive","_stateSnapshotAtLastNewline","_sawLookaheadUnsafeFunctionAfterNewline","_recursiveContinueCount","_asyncSaving","_profiler","_mainContentContainer","jsonString","_externals","rootObject","versionObj","formatFromFile","listDefsObj","rootToken","ResetState","choices","_state","IfAsyncWeCant","StartProfiling","EndProfiling","shouldReturn","VariableStateDidChangeEvent","bind","ResetGlobals","ResetCallstack","originalPointer","ChoosePath","ContinueInternal","SwitchFlow","RemoveFlow","SwitchToDefaultFlow","Continue","ContinueAsync","asyncContinueComplete","millisecsLimitAsync","ValidateExternalBindings","PreContinue","isAsyncTimeLimited","durationStopwatch","ContinueSingleStep","RestoreStateSnapshot","PostContinue","err","PreStep","Step","PostStep","TryFollowDefaultInvisibleChoice","PreSnapshot","change","CalculateNewlineOutputStateChange","OutputStateChange","ExtendedBeyondNewline","NewlineRemoved","DiscardSnapshot","StateSnapshot","PostSnapshot","prevText","currText","prevTagCount","currTagCount","newlineStillExists","NoChange","ContinueMaximally","KnotContainerWithName","pathLengthToUse","CopyStateForBackgroundThreadSave","stateToSave","BackgroundSaveComplete","shouldAddToStream","containerToEnter","VisitContainer","currentContentObj","isLogicOrFlowControl","PerformLogicAndFlowControl","ProcessChoice","contextIdx","NextContent","atStart","VisitChangedContainersDueToDivert","prevAncestor","currentChildOfContainer","currentContainerAncestor","allChildrenEnteredAtStart","enteringAtStart","PopChoiceStringAndTags","choiceOnlyStrVal","showChoice","conditionValue","IsTruthy","startText","choiceOnlyText","reverse","divTarget","currentDivert","intContent","errorMessage","CallExternalFunction","sourceName","evalCommand","output","overrideTunnelReturnTarget","popped","names","expected","errorMsg","contentStackForTag","outputCountConsumed","command","choiceTag","contentStackForString","contentToRetain","rescuedTag","choiceCount","extraNote","eitherCount","divertTarget","maxInt","minInt","randomRange","resultSeed","nextRandom","chosenValue","shuffleIndex","NextSequenceShuffleIndex","listNameVal","generatedListValue","foundItem","targetList","listItemIndex","listEnumerator","randomItem","assignedVal","foundValue","func","funcParams","ChoosePathString","resetCallstack","funcDetail","activityStr","ChooseChoiceIndex","choiceIdx","choiceToChoose","HasFunction","EvaluateFunction","returnTextOutput","trim","outputStreamBefore","stringOutput","textOutput","returned","EvaluateExpression","exprContainer","startCallStackHeight","evalStackHeight","funcName","numberOfArguments","funcDef","fallbackFunctionContainer","foundExternal","lookAheadSafe","valueObj","funcResult","function","returnObj","BindExternalFunctionGeneral","lookaheadSafe","TryCoerce","BindExternalFunction","coercedArgs","apply","UnbindExternalFunction","missingExternals","from","innerContent","ObserveVariable","observer","ObserveVariables","variableNames","observers","RemoveVariableObserver","specificVariableName","variableObservers","newValueObj","globalTags","TagsAtStartOfFlowContainerWithPathString","TagsForContentAtPath","flowContainer","firstContent","BuildStringOfContainer","IncrementContentPointer","didPop","successfulIncrement","nextAncestor","indexInAncestor","allChoices","invisibleChoices","numElementsIntVal","seqContainer","numElements","seqCount","loopIndex","iterationIndex","seqPathStr","sequenceHash","charCodeAt","randomSeed","random","unpickedIndices","chosen","chosenIndex","currentDebugMetadata","errorTypeStr","lineNum","endLineNumber","fileName"],"mappings":"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"}